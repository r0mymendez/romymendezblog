<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:distill="https://distill.pub/journal/" version="2.0">
  <channel>
    <title>Romina Mendez</title>
    <link>https://r0mymendez.github.io/</link>
    <atom:link href="https://r0mymendez.github.io/blog_en.xml" rel="self" type="application/rss+xml"/>
    <description>Romina Mendez's personal blog/ site. Some  posts
on software, agile methodologies , data science and the professor life.
</description>
    <image>
      <title>Romina Mendez</title>
      <url>https://r0mymendez.github.io/image/favicon.ico</url>
      <link>https://r0mymendez.github.io/</link>
    </image>
    <generator>Distill</generator>
    <lastBuildDate>Fri, 10 Jan 2025 00:00:00 +0000</lastBuildDate>
    <item>
      <title>Diagram-as-Code: Creating Dynamic and Interactive Documentation for Visual Content</title>
      <dc:creator>Romina Mendez</dc:creator>
      <link>https://r0mymendez.github.io/posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content</link>
      <description>


&lt;h1 id="diagram-as-code"&gt;üé® Diagram as code&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Diagram as Code&lt;/strong&gt; is an approach that allows you to create diagrams through code instead of traditional graphic tools. Instead of manually building diagrams, you can write code in a text file to define the structure, components, and connections of your diagrams.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content/preview.png" /&gt;&lt;/p&gt;
&lt;p&gt;This code is then translated into graphical images, making it easier to integrate and document in software projects, where it is especially useful for creating and updating architectural and flow diagrams programmatically.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="what-is-diagrams"&gt;What is Diagrams?&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Diagrams&lt;/strong&gt; is a &lt;strong&gt;üêçPython library&lt;/strong&gt; that implements the Diagram as Code approach, enabling you to create architectural infrastructure diagrams and other types of diagrams through code. With Diagrams, you can easily define cloud infrastructure components (such as &lt;code&gt;AWS&lt;/code&gt;, &lt;code&gt;Azure&lt;/code&gt;, and &lt;code&gt;GCP&lt;/code&gt;), network elements, software services, and more, all with just a few lines of code.&lt;/p&gt;
&lt;h3 id="benefits-of-diagram-as-code"&gt;üéâ Benefits of Diagram-as-Code&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;üìù &lt;strong&gt;Representation of Diagrams as Code&lt;/strong&gt;: Create and update diagrams directly from code, ensuring maintainability in agile projects.&lt;/li&gt;
&lt;li&gt;üìë &lt;strong&gt;Automated Documentation&lt;/strong&gt;: Generate visuals from code, keeping diagrams aligned with the current architecture.&lt;/li&gt;
&lt;li&gt;üîÑ &lt;strong&gt;Change Control&lt;/strong&gt;: Track diagram modifications over time.&lt;/li&gt;
&lt;li&gt;üîç &lt;strong&gt;Enhanced Clarity&lt;/strong&gt;: Improve understanding of complex systems with clear, shared visuals.&lt;/li&gt;
&lt;li&gt;‚úèÔ∏è &lt;strong&gt;Customizable&lt;/strong&gt;: Represent cloud infrastructures, workflows, or data pipelines with flexible and tailored visuals.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id="tutorial"&gt;Tutorial&lt;/h1&gt;
&lt;h2 id="library-installation"&gt;üêç Library Installation&lt;/h2&gt;
&lt;p&gt;I was currently using version &lt;code&gt;'0.23.4'&lt;/code&gt; for this tutorial.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;!pip install diagrams==&amp;#39;0.23.4&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1 id="diagrams-nodes"&gt;üé® Diagrams: Nodes&lt;/h1&gt;
&lt;p&gt;The library allows you to create architectural diagrams programmatically, using nodes to represent different infrastructure components and services.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="node-types"&gt;Node Types&lt;/h2&gt;
&lt;p&gt;Nodes in Diagrams represent components from different cloud service providers as well as other architectural elements. Here are the main categories of available nodes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‚òÅÔ∏è &lt;strong&gt;Cloud Providers&lt;/strong&gt;: AWS (Amazon Web Services), Azure, GCP, IBM Cloud, Alibaba Cloud, Oracle Cloud, DigitalOcean, among others.&lt;/li&gt;
&lt;li&gt;üè¢ &lt;strong&gt;On-Premise&lt;/strong&gt;: Represents the infrastructure physically located on the company‚Äôs premises.&lt;/li&gt;
&lt;li&gt;üö¢ &lt;strong&gt;Kubernetes (K8S)&lt;/strong&gt;: Container orchestration system to automate the deployment, scaling, and management of containerized applications (represented by a ship‚Äôs wheel, symbolizing control and navigation).&lt;/li&gt;
&lt;li&gt;üñ•Ô∏è &lt;strong&gt;OpenStack&lt;/strong&gt;: Open-source software platform for creating and managing public and private clouds.&lt;/li&gt;
&lt;li&gt;üîß &lt;strong&gt;Generic&lt;/strong&gt;: Generic nodes that can represent any component not specifically covered by provider-specific nodes (crossed tools, representing different tools in one category).&lt;/li&gt;
&lt;li&gt;‚òÅÔ∏è &lt;strong&gt;SaaS (Software as a Service)&lt;/strong&gt;: Represents applications delivered as a service over the internet, such as Snowflake, chat services (Slack, Teams, Telegram, among others), security (e.g., Okta), or social networks (crossed out phone and cloud for the SaaS concept).&lt;/li&gt;
&lt;li&gt;üîß &lt;strong&gt;Custom&lt;/strong&gt;: Allows users to customize their diagrams using PNG icons stored in a specific folder. This is useful for representing infrastructure components not covered by the default nodes (crossed-out custom tools).&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="programming-languages"&gt;üíª Programming Languages&lt;/h2&gt;
&lt;p&gt;The &lt;strong&gt;Diagrams&lt;/strong&gt; library allows you to use different nodes to represent various programming languages. These nodes are helpful for indicating in your diagrams if any part of your architecture utilizes scripts or components developed in a specific programming language.&lt;/p&gt;
&lt;p&gt;Below, we will showcase all the available languages in the library. If any language is missing, you can add custom nodes by uploading the corresponding logo into a specific folder.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;# Create the diagram object
with diagrams.Diagram(&amp;quot;Programming Languages&amp;quot;, show=False, filename=&amp;quot;languages&amp;quot;):
    # Get all the languages available in this library
    languages = [item for item in dir(diagrams.programming.language) if item[0] != &amp;#39;_&amp;#39;]

    # Divide the representation in two lines
    mid_index = len(languages) // 2
    first_line = languages[:mid_index]
    second_line = languages[mid_index:]

    # Add nodes in the first row
    prev_node = None

    for language in first_line:
        current_node = eval(f&amp;quot;diagrams.programming.language.{language}(language)&amp;quot;)
        if prev_node is not None:
            prev_node &amp;gt;&amp;gt; current_node
        prev_node = current_node

    # Add nodes in the second row
    prev_node = None

    for language in second_line:
        current_node = eval(f&amp;quot;diagrams.programming.language.{language}(language)&amp;quot;)
        if prev_node is not None:
            prev_node &amp;gt;&amp;gt; current_node
        prev_node = current_node

Image(&amp;quot;languages.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content/img/language.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="aws-amazon-web-services"&gt;‚òÅÔ∏è AWS (Amazon Web Services)&lt;/h2&gt;
&lt;p&gt;We can use Amazon nodes, which are organized into several categories, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Analytics and Business&lt;/strong&gt;: aws.analytics, aws.business&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compute and Storage&lt;/strong&gt;: aws.compute, aws.storage, aws.cost&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Database and DevTools&lt;/strong&gt;: aws.database, aws.devtools&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Integration and Management&lt;/strong&gt;: aws.integration, aws.management&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Machine Learning and Mobile&lt;/strong&gt;: aws.ml, aws.mobile&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Networking and Security&lt;/strong&gt;: aws.network, aws.security&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Others&lt;/strong&gt;: aws.blockchain, aws.enduser, aws.engagement, aws.game, aws.general, aws.iot, aws.media, aws.migration, aws.quantum, aws.robotics, aws.satellite&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next, we will represent one of these categories to visualize the available nodes within &lt;code&gt;aws.database&lt;/code&gt;.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;from diagrams import Diagram
from IPython.display import Image
import diagrams.aws.database as aws_database


database_components = []
for item in dir(aws_database):
    if item[0] != &amp;#39;_&amp;#39;:
        if not any(comp.startswith(item) or item.startswith(comp) for comp in database_components):
            database_components.append(item)


with Diagram(&amp;quot;AWS Database&amp;quot;, show=False, filename=&amp;quot;aws_database&amp;quot;):
    mid_index = len(database_components) // 2
    first_line = database_components[:mid_index]
    second_line = database_components[mid_index:]


    prev_node = None
    for item_database in first_line:
        current_node = eval(f&amp;quot;aws_database.{item_database}(item_database)&amp;quot;)
        if prev_node is not None:
            prev_node &amp;gt;&amp;gt; current_node
        prev_node = current_node


    prev_node = None
    for item_database in second_line:
        current_node = eval(f&amp;quot;aws_database.{item_database}(item_database)&amp;quot;)
        if prev_node is not None:
            prev_node &amp;gt;&amp;gt; current_node
        prev_node = current_node

Image(&amp;quot;aws_database.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content/img/database.jpeg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="use-case"&gt;‚òÅÔ∏è Use Case&lt;/h2&gt;
&lt;p&gt;Now, let‚Äôs create a simple blueprint that corresponds to importing a dataset and training a machine learning model on &lt;strong&gt;AWS&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;from diagrams import Diagram, Cluster
from diagrams.aws.storage import S3
from diagrams.aws.analytics import Glue, Athena
import diagrams.aws.ml as ml
from diagrams.aws.integration import StepFunctions
from diagrams.aws.compute import Lambda
from diagrams.aws.network import APIGateway
from IPython.display import Image

with Diagram(&amp;quot;AWS Data Processing Pipeline&amp;quot;, show=False):

    lambda_raw = Lambda(&amp;#39;Get Raw Data&amp;#39;)
    # Buckets de S3
    with Cluster(&amp;quot;Data Lake&amp;quot;):
        s3_rawData = S3(&amp;quot;raw_data&amp;quot;)
        s3_stage = S3(&amp;quot;staging_data&amp;quot;)
        s3_data_capture = S3(&amp;quot;data_capture&amp;quot;)


    athena = Athena(&amp;quot;Athena&amp;quot;)
    s3_rawData &amp;gt;&amp;gt; athena
    s3_stage &amp;gt;&amp;gt; athena
    s3_data_capture &amp;gt;&amp;gt; athena

    #  Step Functions Pipeline
    with Cluster(&amp;quot;Data Processing Pipeline&amp;quot;):
        step_functions = StepFunctions(&amp;quot;Pipeline&amp;quot;)

        # Glue Jobs in Step Functions
        with Cluster(&amp;quot;Glue Jobs&amp;quot;):
            data_quality = Glue(&amp;quot;job_data_quality&amp;quot;)
            transform = Glue(&amp;quot;job_data_transform&amp;quot;)
            dataset_preparation = Glue(&amp;quot;job_dataset_model&amp;quot;)

        # Define Step Functions Flows
        step_functions &amp;gt;&amp;gt; data_quality &amp;gt;&amp;gt; transform &amp;gt;&amp;gt; dataset_preparation
        s3_rawData &amp;gt;&amp;gt; data_quality

    # SageMaker for model training and deployment
    with Cluster(&amp;quot;SageMaker Model Deployment&amp;quot;):
        train_model = ml.SagemakerTrainingJob(&amp;quot;job_train_model&amp;quot;)
        eval_model = ml.SagemakerGroundTruth(&amp;quot;job_evaluate_model&amp;quot;)
        endpoint = ml.SagemakerModel(&amp;quot;model_enpoint&amp;quot;)

    # API Gateway and Lambda for the endpoint
    api_gateway = APIGateway(&amp;quot;API_gateway&amp;quot;)
    lambda_fn = Lambda(&amp;quot;invoke_endpoint&amp;quot;)

    # Connection
    lambda_raw &amp;gt;&amp;gt; s3_rawData
    s3_stage &amp;gt;&amp;gt; train_model &amp;gt;&amp;gt; eval_model &amp;gt;&amp;gt; endpoint
    endpoint &amp;gt;&amp;gt; lambda_fn &amp;gt;&amp;gt; api_gateway
    endpoint &amp;gt;&amp;gt; s3_data_capture
    dataset_preparation &amp;gt;&amp;gt; train_model


Image(&amp;quot;aws_data_processing_pipeline.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content/img/architecture.png" alt="" /&gt;
&lt;p class="caption"&gt;Image description&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h1 id="repository"&gt;Repository&lt;/h1&gt;
&lt;p&gt;Below are the link to all the code, if you find it useful, you can leave a star ‚≠êÔ∏è and follow me to receive notifications of new articles. This will help me grow in the tech community and create more content.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content/img/github.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you want to see how to implement a documentation site using this pipeline you can read the article I published in the following &lt;a href="https://dev.to/r0mymendez/deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus-3516"&gt;link&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h1 id="references"&gt;üìö References&lt;/h1&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;Diagrams:&lt;/strong&gt; &lt;a href="https://diagrams.mingrammer.com/" class="uri"&gt;https://diagrams.mingrammer.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>3d75e92d56a59f2769d531e7e03e1d7b</distill:md5>
      <category>Data</category>
      <category>Python</category>
      <category>Cloud Computing</category>
      <category>AWS</category>
      <guid>https://r0mymendez.github.io/posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content</guid>
      <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
      <media:content url="https://r0mymendez.github.io/posts_en/2025-01-10-diagram-as-code-creating-dynamic-and-interactive-documentation-for-visual-content/preview.png" medium="image" type="image/png" width="800" height="466"/>
    </item>
    <item>
      <title>Deploying Docs-as-Code on AWS: Building Dynamic Documentation Sites in MkDocs and Docusaurus</title>
      <dc:creator>Romina Mendez</dc:creator>
      <link>https://r0mymendez.github.io/posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus</link>
      <description>


&lt;p&gt;The solution includes support for &lt;code&gt;charts&lt;/code&gt; and &lt;code&gt;diagrams&lt;/code&gt;, continuous integration &lt;code&gt;(CI/CD)&lt;/code&gt; using a simple workflow in &lt;code&gt;GitHub Actions&lt;/code&gt;, and automatic deployment using &lt;code&gt;Terraform&lt;/code&gt;. Let‚Äôs get started!&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/preview.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="what-is-documentation-as-code"&gt;What is Documentation as Code?&lt;/h1&gt;
&lt;p&gt;Documentation and its updates are an important process in many companies that develop software, often carried out using different tools, many of which are paid solutions.&lt;br /&gt;
Therefore, in recent times, the concept of &lt;strong&gt;‚Äúdoc as code‚Äù&lt;/strong&gt; has emerged. This means using the same tools and workflows used in software development to &lt;code&gt;manage&lt;/code&gt;, &lt;code&gt;version&lt;/code&gt;, and &lt;code&gt;deploy&lt;/code&gt; documentation.&lt;br /&gt;
This approach not only allows for better tracking of the documentation but also facilitates its maintenance and ensures alignment with the same best practices used in software development, not just in the code but also in the documentation .&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-1.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="tools-for-documentation-as-code"&gt;Tools for Documentation as Code&lt;/h2&gt;
&lt;p&gt;For the development of these sites, it is essential to understand some practices and tools that allow us to implement this approach. Below is a detailed list of the most important aspects to cover in this tutorial.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;üìù &lt;strong&gt;Markdown&lt;/strong&gt;: The most common markup language for writing documentation due to its simplicity and integration with version control platforms and static site generators.&lt;/li&gt;
&lt;li&gt;üóÇÔ∏è &lt;strong&gt;Git&lt;/strong&gt;: Git allows versioning of documentation just like code. Thanks to Git, every change in the documentation is recorded, enabling teams to track edits, revert changes, and collaborate more efficiently.&lt;/li&gt;
&lt;li&gt;üîÑ &lt;strong&gt;Gitflow&lt;/strong&gt;: This methodology provides a structured workflow to manage versions and revisions of documentation, ensuring that changes are approved and tested before reaching production. Gitflow also facilitates collaboration between teams, allowing for safe and organized change management.&lt;/li&gt;
&lt;li&gt;‚òÅÔ∏è &lt;strong&gt;Cloud Services&lt;/strong&gt;: Using services like AWS S3, Netlify, or GitHub Pages, you can deploy documentation at a low cost. These services allow the creation of fast, secure, and easily accessible static sites.&lt;/li&gt;
&lt;li&gt;üåê &lt;strong&gt;Static Site Generators&lt;/strong&gt;: Tools like Docusaurus, Jekyll, or Hugo convert Markdown documentation into a navigable website, allowing you to create rich and organized documentation without a server.&lt;/li&gt;
&lt;li&gt;üöÄ &lt;strong&gt;Continuous Integration (CI/CD)&lt;/strong&gt;: CI/CD pipelines (e.g., GitHub Actions, GitLab CI, or Jenkins) allow you to automatically deploy documentation when a new version is merged or modifications are approved. This ensures the documentation is always up-to-date.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-2.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="advantages-of-docs-as-code"&gt;Advantages of Docs-as-Code&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;‚úÖ Consistency and Quality&lt;/strong&gt;: By using version control and change reviews, the documentation remains consistent and of high quality.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;‚öôÔ∏è Automation&lt;/strong&gt;: CI/CD tools enable automation of documentation deployment, reducing update times and minimizing errors.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ü§ù Efficient Collaboration&lt;/strong&gt;: With tools like Git, teams can collaborate on creating and maintaining documentation without conflicts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîß Simplified Maintenance&lt;/strong&gt;: Maintaining documentation is integrated into the development workflow, making updates easier as the code evolves.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="mkdocs"&gt;üìÑ MkDocs&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MkDocs&lt;/strong&gt; is a static site generator written in &lt;strong&gt;üêçPython,&lt;/strong&gt; designed specifically for documenting projects. Its goal is to simplify creating documentation using Markdown files, which are easy to write and read.&lt;/p&gt;
&lt;p&gt;With minimal configuration, &lt;strong&gt;MkDocs&lt;/strong&gt; converts Markdown files into a navigable and well-structured documentation website, making it ideal for developers and teams who want to keep their documentation up to date.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="mkdocs-material"&gt;‚úèÔ∏è MkDocs Material&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MkDocs Material&lt;/strong&gt; is an advanced theme for &lt;strong&gt;MkDocs&lt;/strong&gt; that follows Google‚Äôs Material Design guidelines.&lt;/p&gt;
&lt;h3 id="key-features-include"&gt;üöÄ Key features include:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;üì± &lt;strong&gt;Responsive Design&lt;/strong&gt;: Automatically adapts to any screen size.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;üé® &lt;strong&gt;Customization&lt;/strong&gt;: Easily modify colors, fonts, favicon, and logo to match your project‚Äôs visual identity.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;üîç &lt;strong&gt;Search Interface&lt;/strong&gt;: Advanced search groups results and highlights searched terms, helping users find the information they need.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;‚ö° &lt;strong&gt;Lazy Loading&lt;/strong&gt;: Implements lazy loading for search results, improving performance and reducing load times.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;üîó &lt;strong&gt;Integrations&lt;/strong&gt;: Compatible with Google Analytics, Disqus, and GitHub, facilitating traffic analysis, user feedback, and direct connection to the project repository.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="mermaid"&gt;‚úèÔ∏è Mermaid&lt;/h2&gt;
&lt;p&gt;Mermaid is a **JavaScript** library for creating diagrams and charts from text. By integrating with MkDocs Material, Mermaid allows you to generate visualizations such as flowcharts, entity-relationship diagrams, and other charts within the documentation without external tools.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-3.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="dynamic-page-jinja"&gt;üß© Dynamic Page: Jinja&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Jinja&lt;/strong&gt; is a library that allows embedding variables and data from Python dictionaries into HTML, making web pages dynamic. This library is commonly used for generating dynamic HTML and sending personalized emails.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="docusaurus-overview"&gt;ü¶ñ Docusaurus Overview&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Docusaurus&lt;/strong&gt; is an open-source project developed by Meta in 2007 that simplifies the creation, deployment, and maintenance of documentation websites in a fast and efficient way. It allows the use of Markdown and MDX to write content, while its core built on React enables full customization of the styles to fit the specific needs of the project.&lt;/p&gt;
&lt;p&gt;Additionally, Docusaurus supports Mermaid through the &lt;code&gt;@docusaurus/theme-mermaid&lt;/code&gt; plugin, enabling the inclusion of charts and diagrams directly within the documentation.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="diagram-as-code"&gt;üé® Diagram as Code&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Diagram as Code&lt;/strong&gt; is an approach that allows you to create diagrams through code, rather than using traditional graphic tools. Instead of manually building diagrams, you write code in a text file to define the structure, components, and connections of your diagrams.&lt;/p&gt;
&lt;p&gt;This code is then translated into graphical images, making it easier to integrate and document in software projects. It‚Äôs especially useful for creating and updating architectural and flow diagrams programmatically.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="diagram-as-code-example-of-creating-cloud-diagrams"&gt;üé® Diagram as Code: Example of Creating Cloud Diagrams&lt;/h2&gt;
&lt;p&gt;As previously mentioned, &lt;strong&gt;Diagrams&lt;/strong&gt; allows you to generate blueprints using the icons of major cloud technologies. The representation of these diagrams is done through nodes, and in our example, we‚Äôll use all cloud-related nodes and AWS services.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-4.png" /&gt;&lt;/p&gt;
&lt;p&gt;For more details on how I created this, you can read my article about &lt;a href="https://dev.to/r0mymendez/doc-as-diagrams-2ci5-temp-slug-2900884?preview=41df4c1f39f0ebe2634f376408ef3ef751cc09bff3c487f9ab7e7b364f729767da9709796b1bff2fc1e2fc925e62087ad52a19c3cd2e0a28d5a4b68d"&gt;Diagram as Code&lt;/a&gt;, and the full implementation can be found in this repository:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/github.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="use-case-creating-a-documentation-site-for-a-machine-learning-project"&gt;üìö Use Case: Creating a Documentation Site for a Machine Learning Project&lt;/h1&gt;
&lt;p&gt;In this use case, I will create a &lt;code&gt;documentation site&lt;/code&gt; for a &lt;strong&gt;machine learning project&lt;/strong&gt; involving üè• hospital data. The goal is to build an interactive documentation site using &lt;strong&gt;MkDocs&lt;/strong&gt; initially and later migrate it to &lt;strong&gt;Docusaurus&lt;/strong&gt;. The site will include both static and dynamic components to meet specific requirements, such as embedding visual diagrams and updating data dynamically from a SQLite database.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="key-features-of-the-documentation-site"&gt;üöÄ Key Features of the Documentation Site&lt;/h2&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;Visual Representations&lt;/strong&gt;: I will embed diagrams created with &lt;strong&gt;Diagrams&lt;/strong&gt; (&lt;code&gt;Diagram as Code&lt;/code&gt;) to illustrate the architecture of the machine learning pipeline effectively.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dynamic Data Updates&lt;/strong&gt;: The documentation will display the version and last update date dynamically, pulling this information from a &lt;strong&gt;SQLite database&lt;/strong&gt; to ensure accuracy and relevance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sample of data&lt;/strong&gt;: The documentation will include a sample from the Synthea patient table, showcasing synthetic data as an example.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id="pages-of-the-site"&gt;üìÑ Pages of the Site&lt;/h2&gt;
&lt;p&gt;For this reason our documentation site will have the following pages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üìÑ Home&lt;/strong&gt;: The homepage of the documentation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üìÑ Tables&lt;/strong&gt;:Explanation of the Synthea data tables and their uses.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üìÑ Architecture&lt;/strong&gt;:A detailed overview of the data processing architecture, hosted on AWS.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üìÑ Glossary&lt;/strong&gt;: A glossary of terms used throughout the project&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="mkdocs-implementation"&gt;MkDocs Implementation&lt;/h2&gt;
&lt;p&gt;In this section, we‚Äôll walk through the steps to set up a documentation project using &lt;strong&gt;MkDocs&lt;/strong&gt; from scratch and explain its organized directory structure.&lt;/p&gt;
&lt;h3 id="prerequisites-for-mkdocs"&gt;üîß Prerequisites for MkDocs&lt;/h3&gt;
&lt;p&gt;To get started, you‚Äôll need to install the following &lt;strong&gt;üêçPython&lt;/strong&gt; libraries:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Install MkDocs and the Material&lt;/strong&gt; &lt;code&gt;bash   pip install mkdocs mkdocs-material&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Install additional libraries to enable dynamic content updating&lt;/strong&gt; &lt;code&gt;bash   pip install aiosql pandas sqlite3 jinja2 shutil&lt;/code&gt; ‚Äî&lt;/p&gt;
&lt;h3 id="mkdocs-project-setting-up"&gt;üîß Mkdocs: Project Setting Up&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Initialize the Project&lt;/strong&gt;&lt;br /&gt;
Start by creating a new MkDocs project. Run the following commands in your terminal:&lt;br /&gt;
&lt;code&gt;bash    mkdocs new mkdocs    cd mkdocs&lt;/code&gt; This command creates a basic MkDocs project with a default structure .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Explore the Directory Structure&lt;/strong&gt;&lt;br /&gt;
Once the MkDocs site is created, you need to add the following files and folders, as they are not included by default. ¬† Remember, the links to the repository are provided at the end of this post for your reference, and each component will be explained in detail below.&lt;/p&gt;
&lt;pre class="plaintext"&gt;&lt;code&gt;üìÅ docs/
  ‚îú‚îÄ‚îÄ üìÅ img/
  ‚îú‚îÄ‚îÄ `architecture.md`
  ‚îú‚îÄ‚îÄ `glossary.md`
  ‚îú‚îÄ‚îÄ `index.md`
  ‚îú‚îÄ‚îÄ `tables.md`
  ‚îú‚îÄ‚îÄ üìÅ template/
  ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ db/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ data/
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hospital.db
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÅ queries/
  ‚îÇ   ‚îú‚îÄ‚îÄ `architecture.md`
  ‚îÇ   ‚îú‚îÄ‚îÄ `glossary.md`
  ‚îÇ   ‚îú‚îÄ‚îÄ `index.md`
  ‚îÇ   ‚îú‚îÄ‚îÄ `tables.md`
  ‚îÇ   ‚îî‚îÄ‚îÄ `update.py`
üìÅ infraestructure/
üìÅ github/
  ‚îú‚îÄ‚îÄ üìÅ workflows/
  ‚îÇ   ‚îú‚îÄ‚îÄ main.yml
üìÑ mkdocs.yml&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="mkdocs-component-overview"&gt;üìÇMkdocs: Component Overview&lt;/h3&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width="11%" /&gt;
&lt;col width="5%" /&gt;
&lt;col width="83%" /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class="header"&gt;
&lt;th&gt;&lt;strong&gt;Component&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Directory&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;&lt;strong&gt;Database (&lt;code&gt;db&lt;/code&gt;)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;db&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Contains the SQLite database (&lt;code&gt;hospital.db&lt;/code&gt;) and queries (&lt;code&gt;metadata.sql&lt;/code&gt;, &lt;code&gt;person.sql&lt;/code&gt;) to manage dynamic data. Learn more about managing SQL queries in Python in my previous article: &lt;a href="https://dev.to/r0mymendez/python-projects-with-sql-strategies-for-effective-query-management-2n5k"&gt;Python Projects with SQL&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;üñãÔ∏è &lt;strong&gt;Templates &amp;amp; Pages&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;template&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Markdown templates: &lt;code&gt;index.md&lt;/code&gt;, &lt;code&gt;tables.md&lt;/code&gt;, &lt;code&gt;architecture.md&lt;/code&gt;, &lt;code&gt;glossary.md&lt;/code&gt;. Supports Mermaid diagrams, embedded images, and database-driven content.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="odd"&gt;
&lt;td&gt;üñºÔ∏è &lt;strong&gt;Static Content (&lt;code&gt;docs&lt;/code&gt;)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;docs&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Final site generated by &lt;code&gt;update.py&lt;/code&gt;, including images (&lt;code&gt;img/&lt;/code&gt;) and dynamic content populated from &lt;code&gt;template&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="even"&gt;
&lt;td&gt;üåê &lt;strong&gt;Infrastructure (&lt;code&gt;infraestructure&lt;/code&gt;)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;infraestructure&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Terraform scripts (&lt;code&gt;main.tf&lt;/code&gt;, &lt;code&gt;variables.tf&lt;/code&gt;) to deploy an S3 bucket for documentation hosting.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3 id="mkdocs-1"&gt;üìÑ Mkdocs&lt;/h3&gt;
&lt;p&gt;Configuring &lt;code&gt;mkdocs.yml&lt;/code&gt; Once we have our project structure set up, we will configure it step by step, starting with the &lt;code&gt;mkdocs.yml file&lt;/code&gt;. This file defines the structure and settings for your documentation site. Here‚Äôs how it should be structured:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;mkdocs.yml&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="yaml"&gt;&lt;code&gt;site_name: Hospital Documentation  
nav:
  - Home: index.md
  - Synthea Tables: tables.md
  - AWS Architectur: architecture.md
  - Glossary: glossary.md
markdown_extensions:
  - pymdownx.superfences:
      custom_fences:
        - name: mermaid
          class: mermaid
theme:
  name: material                &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this &lt;strong&gt;configuration file&lt;/strong&gt;, you can primarily see in the &lt;strong&gt;nav&lt;/strong&gt; section the pages that will be accessible from the menu. Then, we specify the &lt;code&gt;Mermaid&lt;/code&gt; extension, which will be explained in the next section. Finally, the &lt;strong&gt;theme&lt;/strong&gt; section applies the &lt;code&gt;Material theme&lt;/code&gt;, enabling styling and components available within this library.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="mkdocs-mermaid-extension"&gt;‚úèÔ∏è Mkdocs: Mermaid Extension&lt;/h3&gt;
&lt;p&gt;As mentioned earlier, &lt;strong&gt;Mermaid&lt;/strong&gt; is a &lt;strong&gt;JavaScript&lt;/strong&gt; library for creating diagrams and charts from text. Below, we will see some examples. In our case, we will use it to generate an Entity Relationship Diagram (ERD) on the &lt;strong&gt;tables&lt;/strong&gt; page of the documentation.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-5.png" alt="" /&gt;
&lt;p class="caption"&gt;Image description&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;In the repository, you will be able to see how to construct this code based on the Entity Relationship Diagram (ERD) found in the official Synthea documentation. You can also check the example of the tables page in the following link: &lt;a href="https://github.com/r0mymendez/doc-as-code-mkdocs/blob/main/docs/template/tables.md?plain=1"&gt;tables.md&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id="mkdocs-dynamic-content-with-jinja"&gt;‚öôÔ∏è Mkdocs: Dynamic Content with Jinja&lt;/h3&gt;
&lt;p&gt;To enable dynamic content generation for our documentation site, we‚Äôll use &lt;strong&gt;Jinja&lt;/strong&gt; to process templates and replace placeholders with actual data. Below is a step-by-step breakdown:&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Set Up a &lt;code&gt;templates&lt;/code&gt; Folder&lt;/strong&gt;&lt;br /&gt;
Create a folder named &lt;code&gt;templates&lt;/code&gt; to store all Markdown files for the site. These files should include placeholders. For instance, in &lt;code&gt;index.md&lt;/code&gt;, you might have placeholders like &lt;code&gt;{{database.version_date}}&lt;/code&gt; and &lt;code&gt;{{database.version}}&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Utilize Placeholders&lt;/strong&gt;&lt;br /&gt;
Placeholders are dynamic variables in the Markdown files. These variables will be updated automatically using Python dictionaries to inject relevant data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Generate Dynamic Content with &lt;code&gt;update.py&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Prepare your Markdown templates by identifying the sections where dynamic data is required.&lt;br /&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use a Python script (&lt;code&gt;update.py&lt;/code&gt;), available in my repository, to process the templates. The script performs the following tasks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Database Connection&lt;/strong&gt;: Connects to a SQLite database to fetch the latest values.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template Rendering&lt;/strong&gt;: Uses the Jinja library to substitute placeholders with data from the database.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File Generation&lt;/strong&gt;: Outputs updated Markdown files to the &lt;code&gt;docs&lt;/code&gt; folder, ready for rendering in MkDocs.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-6.png" /&gt;&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;from jinja2 import Template
def render_template(template_str, data):
    &amp;quot;&amp;quot;&amp;quot;Render the template with the data.&amp;quot;&amp;quot;&amp;quot;
    template = Template(template_str)
    return template.render(data)
# Data structure
data_dict = {
    &amp;#39;database&amp;#39;: {
        &amp;#39;version&amp;#39;: 1,
        &amp;#39;version_date&amp;#39;: &amp;#39;2024-01-01&amp;#39;
    }
}
# Render the template
rendered_content = render_template(&amp;quot;Data updated to {{database.version_date}}&amp;quot;, data_dict)
print(rendered_content) &lt;/code&gt;&lt;/pre&gt;
&lt;pre class="bash"&gt;&lt;code&gt;Data updated to  2024-10-01 10:20:30&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;By following these steps, you can automate the updating process for your documentation site, ensuring the content remains dynamic and relevant without manual edits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id="dynamic-update-of-data-tables"&gt;Dynamic Update of Data Tables&lt;/h3&gt;
&lt;p&gt;In the next example, we will update the content in the &lt;code&gt;tables.md&lt;/code&gt; file to show an example of the &lt;strong&gt;&lt;code&gt;persons&lt;/code&gt;&lt;/strong&gt; table from the database. To do this, we will create a placeholder &lt;code&gt;{{table.person}}&lt;/code&gt; within the Markdown file. The idea is to dynamically fetch the data from the &lt;strong&gt;&lt;code&gt;persons&lt;/code&gt;&lt;/strong&gt; table, and then use the Jinja library along with pandas to convert the query results into a Markdown table format.&lt;/p&gt;
&lt;p&gt;Here‚Äôs an example of how the &lt;code&gt;tables.md&lt;/code&gt; file looks with the placeholder:&lt;/p&gt;
&lt;pre class="markdown"&gt;&lt;code&gt;#### Example Person Table
## Person Table
{{table.person}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The process is as follows:&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;Query the Database&lt;/strong&gt;: The script will query the &lt;strong&gt;&lt;code&gt;persons&lt;/code&gt;&lt;/strong&gt; table in the SQLite database to fetch relevant records.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Convert to Markdown&lt;/strong&gt;: Using &lt;strong&gt;pandas&lt;/strong&gt;, the results of the query will be converted into a Markdown table format.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replace the Placeholder&lt;/strong&gt;: The &lt;code&gt;{{table.person}}&lt;/code&gt; placeholder in the &lt;code&gt;tables.md&lt;/code&gt; file will be replaced by the generated Markdown table.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="python"&gt;&lt;code&gt;import sqlite3
import pandas as pd
import aiosql


def get_queries():
    sql = aiosql.from_path(&amp;#39;template/db/queries&amp;#39;, &amp;#39;sqlite3&amp;#39;)
    return sql

def get_table_person(db_name):
    &amp;quot;&amp;quot;&amp;quot;Get a DataFrame from the PATIENTS table.&amp;quot;&amp;quot;&amp;quot;
    query = get_queries().get_example_patients.sql 
    connection = sqlite3.connect(db_name)

    df = pd.read_sql_query(query, connection)
    connection.close()
    return df

def update_tables_file(template_path, output_dir, db_name):
    &amp;quot;&amp;quot;&amp;quot;Update the tables.md file&amp;quot;&amp;quot;&amp;quot;
    df = get_table_person(db_name)
    # Convert the dataframe in markdown format
    data_dict = {
        &amp;#39;table&amp;#39;: {
            &amp;#39;person&amp;#39;: df.to_markdown(index=False)  
        }
    }


print(get_table_person(&amp;quot;hospital.db&amp;quot;))  &lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;This way, the documentation always reflects up-to-date data, displaying dynamic examples based on the actual content from the database.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id="mkdocs-final-workflow"&gt;‚öôÔ∏è Mkdocs: Final Workflow&lt;/h3&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;Create Templates&lt;/strong&gt;: Develop your pages in the &lt;code&gt;docs/template&lt;/code&gt; directory.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Run &lt;code&gt;update.py&lt;/code&gt;&lt;/strong&gt;: Populate dynamic content and generate the final files in &lt;code&gt;docs/output&lt;/code&gt;.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Preview Locally&lt;/strong&gt;: Use &lt;code&gt;mkdocs serve&lt;/code&gt; to preview the site on localhost.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build for Deployment&lt;/strong&gt;: Use &lt;code&gt;mkdocs build&lt;/code&gt; to generate a static site in the &lt;code&gt;docs/&lt;/code&gt; folder.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deploy&lt;/strong&gt;: Use Terraform to deploy the site to an AWS S3 bucket. Refer to the deployment section of this post for detailed instructions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-7.png" /&gt;&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-8.png" alt="" /&gt;
&lt;p class="caption"&gt;I&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h2 id="docusaurus-implementation"&gt;ü¶ñ Docusaurus Implementation&lt;/h2&gt;
&lt;p&gt;In the following sections, I will provide detailed steps and insights on how to implement a documentation site using &lt;strong&gt;Docusaurus&lt;/strong&gt;. This includes setup, customization, and deployment options.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="key-features-of-docusaurus"&gt;üöÄ Key Features of Docusaurus&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;üì∂ &lt;strong&gt;Mermaid Support&lt;/strong&gt;: Similar to MkDocs, Docusaurus supports Mermaid for embedding diagrams.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;‚öõÔ∏è &lt;strong&gt;React Components&lt;/strong&gt;: Built on React, Docusaurus enables the integration of dynamic components into your documentation.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;üîÑ &lt;strong&gt;Dynamic Content&lt;/strong&gt;: Leverages Python scripts to fetch and update content dynamically from an SQLite database.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="docusaurus-setup-from-scratch"&gt;üîß Docusaurus Setup: From Scratch&lt;/h3&gt;
&lt;p&gt;To get started with Docusaurus, we follow a quick setup process, which is very similar to the steps we used for MkDocs but with different tools.&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Create a New Docusaurus Project:&lt;/strong&gt; First, install Node.js and run the following command to create a new Docusaurus site:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;npx create-docusaurus@latest my-website classic&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Install Mermaid Package&lt;/strong&gt;: To enable Mermaid diagrams, install the required package:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;npm install @docusaurus/theme-mermaid&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run the Development Server&lt;/strong&gt;: Once installed, navigate to your project directory and run the development server:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;cd my-website
npx docusaurus start&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Visit the Site&lt;/strong&gt;: Your site will be live locally at: &lt;code&gt;http://localhost:3000&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h3 id="docusaurus-customization-configuration"&gt;üîß Docusaurus Customization: Configuration&lt;/h3&gt;
&lt;p&gt;The configuration file &lt;code&gt;docusaurus.config.js&lt;/code&gt; is where we customize the title, theme, navigation, and enable features like Mermaid for diagram rendering. Example snippet for enabling Mermaid:&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;module.exports = {
  title: &amp;#39;Hospital Documentation&amp;#39;,
  tagline: &amp;#39;Documentation for Hospital Data ML Project&amp;#39;,
  favicon: &amp;#39;img/favicon.ico&amp;#39;,
  url: &amp;#39;https://your-site-url.com&amp;#39;,
  markdown: {
    mermaid: true,  // Enable Mermaid diagrams
  },
  themeConfig: {
    navbar: {
      title: &amp;#39;Hospital Docs&amp;#39;,
      items: [
        { to: &amp;#39;docs/&amp;#39;, label: &amp;#39;Home&amp;#39;, position: &amp;#39;left&amp;#39; },
        { to: &amp;#39;docs/tables&amp;#39;, label: &amp;#39;Tables&amp;#39;, position: &amp;#39;left&amp;#39; },
        { to: &amp;#39;docs/architecture&amp;#39;, label: &amp;#39;Architecture&amp;#39;, position: &amp;#39;left&amp;#39; },
        { to: &amp;#39;docs/glossary&amp;#39;, label: &amp;#39;Glossary&amp;#39;, position: &amp;#39;left&amp;#39; },
      ],
    },
    footer: {
      style: &amp;#39;dark&amp;#39;,
      links: [
        { label: &amp;#39;GitHub&amp;#39;, href: &amp;#39;https://github.com/your-repo&amp;#39; },
      ],
    },
  },
};&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id="docusaurus-customizing-the-homepage"&gt;üîß Docusaurus Customizing the Homepage&lt;/h3&gt;
&lt;p&gt;To customize the homepage, we modify the &lt;code&gt;src/components/HomepageFeatures/index.js&lt;/code&gt; file. Here, you can adjust the &lt;strong&gt;FeatureList&lt;/strong&gt; object to update the features displayed on the homepage.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-9.png" alt="" /&gt;
&lt;p class="caption"&gt;Image description&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h3 id="docusaurus-content-organization-and-structure"&gt;üìÇ Docusaurus Content Organization and Structure&lt;/h3&gt;
&lt;p&gt;Just like in &lt;strong&gt;MkDocs&lt;/strong&gt;, Docusaurus supports &lt;strong&gt;Markdown files&lt;/strong&gt; for content, and we organize the structure as follows: 1. &lt;strong&gt;Template Folder&lt;/strong&gt;: Store your Markdown files in the &lt;code&gt;docs/template&lt;/code&gt; directory, and create a Python script (similar to &lt;code&gt;update.py&lt;/code&gt;) to fetch and populate dynamic data into these templates. 2. &lt;strong&gt;Category File (&lt;code&gt;__category__.json&lt;/code&gt;)&lt;/strong&gt;: To manage the order of documents in the sidebar, create a &lt;code&gt;__category__.json&lt;/code&gt; file in each folder. For example:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;Architecture
  ‚îú‚îÄ‚îÄ architecture.md
  ‚îú‚îÄ‚îÄ img
  ‚îî‚îÄ‚îÄ __category__.json&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;__category__.json&lt;/code&gt; Example&lt;/strong&gt;: &lt;code&gt;json    {      "label": "Architecture",      "position": 2,      "link": {        "type": "generated-index",        "description": "AWS Data Processing Blueprint"      }    }&lt;/code&gt;&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-10.png" alt="" /&gt;
&lt;p class="caption"&gt;Image description&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h3 id="dynamic-data-with-jinja"&gt;‚öôÔ∏è Dynamic Data with Jinja&lt;/h3&gt;
&lt;p&gt;To incorporate dynamic content, such as database tables, we use a &lt;strong&gt;üêçPython&lt;/strong&gt; script named &lt;code&gt;update.py&lt;/code&gt;, which you can find in the repository.&lt;/p&gt;
&lt;p&gt;This script fetches data from a &lt;strong&gt;SQLite&lt;/strong&gt; database and processes the Markdown files stored in the &lt;code&gt;templates&lt;/code&gt; folder. It then updates these files with the fetched data and copies them into the &lt;code&gt;docs&lt;/code&gt; folder, preparing them for site rendering.&lt;/p&gt;
&lt;p&gt;This workflow ensures that the content remains up-to-date and ready for deployment, following a similar approach to what we implemented with MkDocs.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="docusaurus-final-workflow"&gt;‚öôÔ∏è Docusaurus: Final Workflow&lt;/h3&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;Create Templates&lt;/strong&gt;: Develop your Markdown files within the &lt;code&gt;docs/template&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Run Python Script&lt;/strong&gt;: Use the script to dynamically populate data into the templates.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Preview Locally&lt;/strong&gt;: Run &lt;code&gt;npx docusaurus start&lt;/code&gt; to preview the site.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Build for Deployment&lt;/strong&gt;: Once ready, use &lt;code&gt;npx docusaurus build&lt;/code&gt; to generate the static site.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deploy&lt;/strong&gt;: Host the static files on your preferred platform, such as AWS S3.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/img-11.png" alt="" /&gt;
&lt;p class="caption"&gt;Image description&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h2 id="deployment"&gt;üöÄ Deployment&lt;/h2&gt;
&lt;p&gt;In this section, we will cover the &lt;strong&gt;deployment process&lt;/strong&gt; for both &lt;strong&gt;MkDocs&lt;/strong&gt; and &lt;strong&gt;Docusaurus&lt;/strong&gt; using &lt;strong&gt;AWS S3&lt;/strong&gt; for hosting. While the deployment steps are the same for both tools, the installation processes differ, with &lt;strong&gt;MkDocs&lt;/strong&gt; being Python-based and &lt;strong&gt;Docusaurus&lt;/strong&gt; being JavaScript-based.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="infrastructure-setup-with-terraform"&gt;Infrastructure Setup with Terraform&lt;/h3&gt;
&lt;p&gt;To deploy a static documentation site to &lt;strong&gt;AWS S3&lt;/strong&gt;, we use Terraform to provision and configure the required resources. The setup defines the S3 bucket, enables static website hosting, and configures public access with a bucket policy to allow read-only access. You can find the &lt;strong&gt;&lt;code&gt;main.tf&lt;/code&gt;&lt;/strong&gt; file in the repository.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="key-components-for-s3-deployment"&gt;üöÄ Key Components for S3 Deployment&lt;/h3&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;S3 Bucket Creation&lt;/strong&gt;: The resource to create the S3 bucket where the documentation will be hosted.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Static Website Hosting&lt;/strong&gt;: Configuration for static web hosting, setting the &lt;code&gt;index.html&lt;/code&gt; and &lt;code&gt;error.html&lt;/code&gt; as the main and error documents.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Public Access Configuration&lt;/strong&gt;: Manages public access to the S3 bucket, ensuring it is configured for read-only access.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bucket Policy&lt;/strong&gt;: Allows public access to retrieve the documentation content from the S3 bucket.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can access the complete &lt;strong&gt;Terraform file&lt;/strong&gt; and the corresponding configurations for deploying the site in the repository:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Terraform Configuration File&lt;/strong&gt;: * &lt;a href="https://github.com/r0mymendez/doc-as-code-mkdocs/tree/main/infraestructure"&gt;mkdocs file&lt;/a&gt; * &lt;a href="https://github.com/r0mymendez/doc-as-code-docusaurus/tree/main/infraestructure"&gt;docusaurus file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitHub Action Workflow for Automatic Deployment&lt;/strong&gt;: A CI/CD pipeline to automate the deployment process is also included in the repository. * &lt;a href="https://github.com/r0mymendez/doc-as-code-mkdocs/blob/main/.github/workflows/main.yml"&gt;mkdocs file&lt;/a&gt; * &lt;a href="https://github.com/r0mymendez/doc-as-code-docusaurus/blob/main/.github/workflows/main.yml"&gt;docusaurus file&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;GitHub Actions Configuration&lt;/strong&gt; Make sure to configure your AWS credentials in the &lt;strong&gt;GitHub repository secrets&lt;/strong&gt; under &lt;strong&gt;Settings&lt;/strong&gt; &amp;gt; &lt;strong&gt;Secrets&lt;/strong&gt; &amp;gt; &lt;strong&gt;Actions&lt;/strong&gt;. This will allow GitHub Actions to securely access your AWS account and perform actions like uploading files to S3 when you push changes to the &lt;code&gt;main&lt;/code&gt; branch.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id="repositories"&gt;Repositories&lt;/h3&gt;
&lt;p&gt;Below are the links to all the code to deploy your documentation site. If you find it useful, you can leave a star ‚≠êÔ∏è and follow me to receive notifications of new articles. This will help me grow in the tech community and create more content.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MkDocs Deployment&lt;/strong&gt;: &lt;a href="https://github.com/r0mymendez/doc-as-code-mkdocs"&gt;GitHub Repository for MkDocs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/github-1.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Docusaurus Deployment&lt;/strong&gt;: &lt;a href="https://github.com/r0mymendez/doc-as-code-docusaurus"&gt;GitHub Repository for Docusaurus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/img/github-2.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="final-conclusions-mkdocs-vs.-docusaurus"&gt;üîç Final Conclusions: MkDocs vs.¬†Docusaurus&lt;/h2&gt;
&lt;p&gt;Both solutions are easy to implement, but in the following items, we can explore some differences, and what is the best solution depends on the context, knowledge, and complexity you may need to implement.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;üíª &lt;strong&gt;Language &amp;amp; Customization&lt;/strong&gt;:&lt;br /&gt;
&lt;strong&gt;MkDocs&lt;/strong&gt; is Python-based, with simple YAML configurations and templates, ideal for quick setups. On the other hand, &lt;strong&gt;Docusaurus&lt;/strong&gt; is React-based, offering advanced customization and interactive components, making it more suitable for users needing more control over visuals.&lt;/li&gt;
&lt;li&gt;üìë &lt;strong&gt;Markdown &amp;amp; Rendering&lt;/strong&gt;:&lt;br /&gt;
Both use Markdown, but &lt;strong&gt;Docusaurus&lt;/strong&gt; allows for interactive elements, making it better for dynamic content.&lt;/li&gt;
&lt;li&gt;‚öôÔ∏è &lt;strong&gt;Complexity&lt;/strong&gt;:&lt;br /&gt;
&lt;strong&gt;Docusaurus&lt;/strong&gt; is better for complex documentation applications, such as those with login systems. &lt;strong&gt;MkDocs&lt;/strong&gt; is simpler but &lt;strong&gt;Docusaurus&lt;/strong&gt; offers more flexibility for styling and features.&lt;/li&gt;
&lt;li&gt;üë• &lt;strong&gt;Community&lt;/strong&gt;:&lt;br /&gt;
&lt;strong&gt;Docusaurus&lt;/strong&gt; has a strong community with Discord and 74 plugins, while &lt;strong&gt;MkDocs&lt;/strong&gt; relies on GitHub discussions for community support.&lt;/li&gt;
&lt;li&gt;‚òÅÔ∏è &lt;strong&gt;Amazon Deployment&lt;/strong&gt;:&lt;br /&gt;
You can deploy a static site to &lt;strong&gt;S3&lt;/strong&gt;, reducing deployment costs, and also use CI/CD for automatic deployment.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id="references"&gt;üìö References&lt;/h1&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;Mkdocs&lt;/strong&gt;: &lt;a href="https://www.mkdocs.org/" class="uri"&gt;https://www.mkdocs.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mkdocs-Material&lt;/strong&gt;: &lt;a href="https://squidfunk.github.io/mkdocs-material/" class="uri"&gt;https://squidfunk.github.io/mkdocs-material/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Diagrams&lt;/strong&gt;: &lt;a href="https://diagrams.mingrammer.com/" class="uri"&gt;https://diagrams.mingrammer.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docusaurus&lt;/strong&gt;: &lt;a href="https://docusaurus.io/" class="uri"&gt;https://docusaurus.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jinja&lt;/strong&gt;: &lt;a href="https://jinja.palletsprojects.com/en/stable/" class="uri"&gt;https://jinja.palletsprojects.com/en/stable/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Git Book - What is doc as code&lt;/strong&gt;: &lt;a href="https://www.gitbook.com/blog/what-is-docs-as-code" class="uri"&gt;https://www.gitbook.com/blog/what-is-docs-as-code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write the docs&lt;/strong&gt;: &lt;a href="https://www.writethedocs.org/guide/docs-as-code/" class="uri"&gt;https://www.writethedocs.org/guide/docs-as-code/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>5903a0294c1d6b46fd2712d4c045765b</distill:md5>
      <category>Data</category>
      <category>Python</category>
      <category>Cloud Computing</category>
      <category>AWS</category>
      <guid>https://r0mymendez.github.io/posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus</guid>
      <pubDate>Thu, 09 Jan 2025 00:00:00 +0000</pubDate>
      <media:content url="https://r0mymendez.github.io/posts_en/2025-01-10-deploying-docs-as-code-on-aws-building-dynamic-documentation-sites-in-mkdocs-and-docusaurus/preview.png" medium="image" type="image/png" width="800" height="464"/>
    </item>
    <item>
      <title>Efficiently Querying JSON Data in Python: Exploring the MET Museum's Artworks</title>
      <dc:creator>Romina Mendez</dc:creator>
      <link>https://r0mymendez.github.io/posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks</link>
      <description>


&lt;p&gt;While working on several projects that required processing complex and nested &lt;strong&gt;JSON&lt;/strong&gt; data in &lt;strong&gt;üêçPython&lt;/strong&gt;, I explored various methods for handling these structures. I eventually discovered the &lt;strong&gt;JMESPath&lt;/strong&gt; library, which aims to simplify querying and filtering JSON structures.&lt;/p&gt;
&lt;p&gt;In this article, I demonstrate how to use the &lt;strong&gt;JMESPath&lt;/strong&gt; library to query and filter &lt;strong&gt;JSON&lt;/strong&gt; data. To find a suitable dataset for these examples, I thought about one of my favorite activities when I travel: visiting museums. The üèõÔ∏è &lt;strong&gt;Metropolitan Museum of Art (MET)&lt;/strong&gt;, one of the largest and most prestigious museums in the world, seemed like a perfect choice, as it offers an &lt;strong&gt;API&lt;/strong&gt; that provides access to a vast collection of artwork. In this article, we‚Äôll focus on the works of &lt;strong&gt;Vincent van Gogh&lt;/strong&gt; and the collections of European painters to explore the potential of &lt;strong&gt;JMESPath&lt;/strong&gt; for effectively handling JSON data.&lt;/p&gt;
&lt;p&gt;Additionally, I will showcase how to use &lt;strong&gt;AWS CLI&lt;/strong&gt; to interact with the data stored in a ü™£ bucket that contains the downloaded &lt;strong&gt;JSON files&lt;/strong&gt; from the MET API.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/flow.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="met-museum-of-new-york"&gt;üèõÔ∏è MET Museum of New York&lt;/h2&gt;
&lt;p&gt;The &lt;strong&gt;Metropolitan Museum of Art (MET)&lt;/strong&gt;, founded in &lt;code&gt;1870&lt;/code&gt; and situated in Manhattan, üóΩ New York City, stands as one of the world‚Äôs most prestigious cultural institutions. Spanning over &lt;code&gt;186,000&lt;/code&gt; square meters, the museum houses a diverse collection that encompasses more than üñºÔ∏è&lt;code&gt;5,000 years&lt;/code&gt; of art history. Through its public API, the MET offers detailed insights into its &lt;code&gt;19 departments&lt;/code&gt;, featuring an extensive array of works that range from ancient Egyptian, Greek, and Roman art to masterpieces by renowned artists such as Monet, Van Gogh, and Raphael.&lt;/p&gt;
&lt;p&gt;The following üìä plot illustrates the distribution of artworks across these various departments, using data retrieved from the MET‚Äôs public API.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/met.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="introduction-to-jmespath"&gt;üìÑ Introduction to JMESPath&lt;/h2&gt;
&lt;h3 id="what-is-jmespath"&gt;What is JMESPath?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;JMESPath&lt;/strong&gt; is a query language for JSON that allows you to search, extract, and manipulate elements from a JSON document. This query language can be implemented with the Azure and AWS CLIs, where it simplifies filtering and transforming JSON data.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/preview_flow.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="installation-of-jmespath"&gt;Installation of JMESPath&lt;/h3&gt;
&lt;p&gt;To get started, you need to install the &lt;strong&gt;JMESPath&lt;/strong&gt; library. The version used in this tutorial is &lt;code&gt;'0.10.0'&lt;/code&gt;. Simply run the following command:&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;pip install jmespath&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="json-data-structure"&gt;üìÑ JSON Data Structure&lt;/h2&gt;
&lt;p&gt;JSON, or JavaScript Object Notation, is a lightweight data format commonly used for data interchange between a server and a client. Here are key elements of JSON structure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üè∑Ô∏è Main Object:&lt;/strong&gt; The JSON object starts and ends with {}, encapsulating all data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üè∑Ô∏è Key-Value Pair:&lt;/strong&gt; Each element is a key-value pair, where the key is a string, and the value can be any data type (e.g., string, number, boolean, array, object).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üè∑Ô∏è Nested JSON Object:&lt;/strong&gt; JSON objects can contain other objects within them, forming nested structures for complex data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üè∑Ô∏è Array of Objects:&lt;/strong&gt; Arrays [ ] hold lists of values, including other objects, useful for grouping similar elements.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/json.png" style="display:¬†block; ¬† margin-left:¬†auto; ¬† margin-right:¬†auto; ¬† width:¬†50%;" width="602" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="met-museum-api-exploring-van-goghs-masterpieces"&gt;üèõÔ∏è¬†MET Museum API: Exploring Van Gogh‚Äôs Masterpieces&lt;/h2&gt;
&lt;p&gt;The following example will focus on one of &lt;strong&gt;Vincent van Gogh‚Äôs&lt;/strong&gt; most renowned works, ‚ÄúSelf-Portrait with a Straw Hat (obverse: The Potato Peeler).‚Äù Painted in &lt;code&gt;1887&lt;/code&gt;, this piece is part of the MET‚Äôs European Paintings collection and reflects Van Gogh‚Äôs evolving artistic style, influenced by both Impressionism and Neo-Impressionism.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://collectionapi.metmuseum.org/api/collection/v1/iiif/436532/1671316/main-image" style="display: block;   margin-left: auto;   margin-right: auto;   width: 50%;" style="width:35.0%" alt="" /&gt;
&lt;p class="caption"&gt;object_436532 - &lt;strong&gt;Van Gogh, V. (1887)&lt;/strong&gt;. Self-Portrait with a Straw Hat (obverse: The Potato Peeler)&lt;br /&gt;
&lt;a href="https://www.metmuseum.org/art/collection/search/436532"&gt;Oil on canvas. The Metropolitan Museum of Art&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Next, we will make a request to the Met Museum API to retrieve data, but firstly we will define a function to handle the request, as shown in the following code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="python"&gt;&lt;code&gt;def get_met_museum_data(method:str,url:str = &amp;#39;https://collectionapi.metmuseum.org/&amp;#39;)-&amp;gt;json:
    # get the data from the Met Museum API
    response = requests.get(f&amp;quot;{url}{method}&amp;quot;)
    if response.status_code == 200:
        return response.json()
    else:
        return f&amp;quot;‚ùå Error getting data from Met Museum API, status_code: {response.status_code&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="python"&gt;&lt;code&gt;URL = &amp;#39;public/collection/v1/objects/436532&amp;#39;
response = get_met_museum_data(method = URL)
response&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;This request returns a dictionary that has 57 keys and 4 lists of nested dictionaries.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id="selecting-keys-from-a-json-object"&gt;Selecting Keys from a JSON Object&lt;/h3&gt;
&lt;h3 id="accessing-lists-of-objects"&gt;Accessing Lists of Objects&lt;/h3&gt;
&lt;p&gt;When working with JSON data, it‚Äôs common to encounter lists of objects, each containing multiple keys and values. Often, you may want to extract only specific pieces of information that are relevant to your analysis from these objects.&lt;/p&gt;
&lt;p&gt;Let‚Äôs examine an example using the üèõÔ∏è MET Museum API‚Äôs response for object ID &lt;code&gt;436532&lt;/code&gt;, which corresponds to üñºÔ∏è &lt;strong&gt;‚ÄúSelf-Portrait with a Straw Hat (obverse: The Potato Peeler)‚Äù&lt;/strong&gt;. Here, we‚Äôll extract key information like the title, year, artist, and tags related to the artwork.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;# Get the following keys from the JSON response obtained from the Met Museum API for object ID 436532: title, year, artist, and tags

# Define the keys to be extracted
query = &amp;quot;[title,objectBeginDate,constituents[0].name,tags[*].term]&amp;quot;

# Use JMESPath to search and extract the selected keys
result = jmespath.search(query, response)

# Display the result
result&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="bash"&gt;&lt;code&gt;[&amp;#39;Self-Portrait with a Straw Hat (obverse: The Potato Peeler)&amp;#39;,
 1887,
 &amp;#39;Vincent van Gogh&amp;#39;,
 [&amp;#39;Men&amp;#39;, &amp;#39;Self-portraits&amp;#39;]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we are selecting the following keys from the JSON response:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üñºÔ∏è Title&lt;/strong&gt;: The title of the artwork.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üìÖ Year&lt;/strong&gt;: The year the artwork was created (&lt;code&gt;objectBeginDate&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üë®‚Äçüé® Artist&lt;/strong&gt;: The name of the artist (&lt;code&gt;constituents[0].name&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üè∑Ô∏è Tags&lt;/strong&gt;: Terms related to the artwork (&lt;code&gt;tags[*].term&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The resulting &lt;code&gt;result&lt;/code&gt; variable will contain only the specified fields, allowing us to focus on the desired information without needing to manually parse through the entire JSON object.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="customizing-the-output-with-key-aliases"&gt;Customizing the Output with Key Aliases&lt;/h4&gt;
&lt;p&gt;In some cases, you may want to rename keys or adjust the output structure for clarity. With &lt;strong&gt;JMESPath&lt;/strong&gt;, you can create aliases for keys to produce a more descriptive result, especially useful when dealing with nested data or similarly named fields.&lt;/p&gt;
&lt;p&gt;We can extend the previous example by assigning aliases to each field, making the output more readable and aligned with our analysis needs:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;query = &amp;quot;&amp;quot;&amp;quot;{ 
      title_name: title,
      date: objectBeginDate,
      artist_name: constituents[0].name,
      tags_name: tags[*].term
}&amp;quot;&amp;quot;&amp;quot;
result = jmespath.search(query, response)
result &lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id="some-other-queries-we-can-make"&gt;Some Other Queries We Can Make&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;To retrieve a list of element measurements from the üñºÔ∏è artworks.&lt;/strong&gt; &amp;gt; In this query, [*] allows us to iterate over each object in the measurements list, enabling the extraction of the elementMeasurements field from each object.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;# Retrieve the &amp;#39;elementMeasurements&amp;#39; field from each object in the &amp;#39;measurements&amp;#39; list
query = &amp;quot;measurements[*].elementMeasurements&amp;quot;
result = jmespath.search(query, response)
result &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The following query returns detailed measurements of each artwork&lt;/strong&gt; &amp;gt; Here, [] allows us to navigate through the array of measurements, while .* retrieves all elements from the nested elementMeasurements, providing a comprehensive output of measurement details.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;# Example (assuming nested structure):
query = &amp;quot;measurements[].elementMeasurements[].*&amp;quot;
result = jmespath.search(query, response)
result &lt;/code&gt;&lt;/pre&gt;
&lt;pre class="bash"&gt;&lt;code&gt;[[40.6, 31.8], [6.0325, 52.7051, 43.1801]]&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="processing-van-goghs-artworks"&gt;üñºÔ∏è Processing Van Gogh‚Äôs Artworks&lt;/h2&gt;
&lt;p&gt;In this section, we will retrieve and process data for a collection of Van Gogh‚Äôs artworks using their unique IDs. Below is a list of object IDs corresponding to various paintings by Vincent van Gogh available through the &lt;strong&gt;MET Museum API&lt;/strong&gt;.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;ids_objects = [335538, 436527, 436530, 436532, 436529, 436525, 436534, 336318, 436526,437998, 436533, 436531, 436535, 849056, 335537, 336327, 849055, 437980, 436528, 459193, 437984, 335536, 459123, 436524, 436536, 438722, 849054, 849052]

response_vg_art = []

for id_object in tqdm(ids_objects):
    response = get_met_museum_data(method = f&amp;#39;public/collection/v1/objects/{id_object}&amp;#39;)
    response_vg_art.append(response)&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="use-cases"&gt;Use Cases&lt;/h3&gt;
&lt;p&gt;Next, we will discuss a series of use cases that will allow us to implement code using &lt;strong&gt;JMESPath&lt;/strong&gt; and perform queries on Van Gogh artworks retrieved from the API data.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/use-cases.png" /&gt;&lt;/p&gt;
&lt;h4 id="case-1-artworks-from-1888-onwards"&gt;üé® Case 1: Artworks from 1888 onwards&lt;/h4&gt;
&lt;p&gt;From &lt;code&gt;1888&lt;/code&gt; onwards, when &lt;strong&gt;Van Gogh&lt;/strong&gt; moved to the south of France, his artistic production increased dramatically. During this period, he created some of his most iconic works, such as &lt;strong&gt;‚ÄúSunflowers‚Äù&lt;/strong&gt;, &lt;strong&gt;‚ÄúThe Yellow House‚Äù&lt;/strong&gt; and &lt;strong&gt;‚ÄúThe Starry Night‚Äù&lt;/strong&gt;. Let‚Äôs take a look at his works created from this year onwards.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;query = &amp;quot;[?objectEndDate&amp;gt;=`1888`].[title, objectEndDate]&amp;quot;
result = jmespath.search(query, response_vg_art)
result&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="bash"&gt;&lt;code&gt;[[&amp;#39;The Flowering Orchard&amp;#39;, 1888],
 [&amp;#39;Oleanders&amp;#39;, 1888],
 [&amp;quot;L&amp;#39;Arl√©sienne: Madame Joseph-Michel Ginoux (Marie Julien, 1848‚Äì1911)&amp;quot;, 1889],
 [&amp;#39;Bouquet of Flowers in a Vase&amp;#39;, 1890],
 [&amp;#39;Roses&amp;#39;, 1890],
 [&amp;#39;Street in Saintes-Maries-de-la-Mer&amp;#39;, 1888],
 [&amp;#39;First Steps, after Millet&amp;#39;, 1890],
 [&amp;#39;Olive Trees&amp;#39;, 1890],
 [&amp;#39;Shoes&amp;#39;, 1888],
 [&amp;#39;Wheat Field with Cypresses&amp;#39;, 1889],
 [&amp;#39;Portrait of Doctor Gachet or Man with a Pipe&amp;#39;, 1890],
 [&amp;#39;Wheat Field&amp;#39;, 1888],
 [&amp;#39;Corridor in the Asylum&amp;#39;, 1889],
 [&amp;#39;Cypresses&amp;#39;, 1889],
 [&amp;#39;Irises&amp;#39;, 1890],
 [&amp;#39;La Berceuse (Woman Rocking a Cradle; Augustine-Alix Pellicot Roulin, 1851‚Äì1930)&amp;#39;,
  1889],
 [&amp;#39;The Zouave&amp;#39;, 1888],
 [&amp;#39;Madame Roulin and Her Baby&amp;#39;, 1888],
 [&amp;#39;Women Picking Olives&amp;#39;, 1889]]&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id="case-2-sorting-van-goghs-works-by-year"&gt;üé® Case 2: Sorting Van Gogh‚Äôs Works by Year&lt;/h4&gt;
&lt;p&gt;If we want to display Van Gogh‚Äôs works created from &lt;code&gt;1888&lt;/code&gt; onwards, sorted by the year of creation, we can use the sort_by function in &lt;strong&gt;JMESPath&lt;/strong&gt;. This function allows us to sort the results based on a specific field.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;# JMESPath query to filter and sort artworks created in or after 1888 by year
query = &amp;quot;sort_by([?objectEndDate &amp;gt;= `1888`], &amp;amp;objectEndDate)[].[title, objectEndDate]&amp;quot;

# Applying the query to get sorted results
result = jmespath.search(query, response_vg_art)

# Display the sorted results
result&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;&lt;code&gt;sort_by&lt;/code&gt;&lt;/strong&gt;: This function sorts the list of artworks based on the specified key, in this case, &lt;code&gt;objectEndDate&lt;/code&gt;. The &lt;code&gt;&amp;amp;&lt;/code&gt; symbol is used to indicate the sorting key.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;&lt;code&gt;[?objectEndDate &amp;gt;=&lt;/code&gt;1888&lt;code&gt;]&lt;/code&gt;&lt;/strong&gt;: This part filters the artworks to include only those created in or after &lt;code&gt;1888&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;&lt;code&gt;[].[title, objectEndDate]&lt;/code&gt;&lt;/strong&gt;: Finally, this projects the results to show only the &lt;strong&gt;title&lt;/strong&gt; and &lt;strong&gt;year&lt;/strong&gt; of each artwork.&lt;/p&gt;
&lt;p&gt;By using this query, we can efficiently retrieve and display Van Gogh‚Äôs works from the specified period in chronological order, allowing for better analysis and understanding of his artistic output during these significant years.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="case-3-identifying-important-works-by-vincent-van-gogh"&gt;üé® Case 3: Identifying Important Works by Vincent van Gogh&lt;/h4&gt;
&lt;p&gt;Let‚Äôs imagine that we are digital curators at the &lt;strong&gt;Metropolitan Museum of Art (MET)&lt;/strong&gt; and we have been tasked with identifying the most important works by Van Gogh for marketing campaigns and educational programs. To do so, we will use the isHighlight key from the artwork data.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;isHighlight&lt;/code&gt; field indicates whether a work is considered one of the most significant pieces in the collection. When the field is set to true, it means that the work is highlighted for its importance.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; When querying for boolean values in JMESPath, we need to use lowercase &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; to ensure the query functions correctly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;To find the highlighted works, we can use the following query:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;# JMESPath query to filter and retrieve important Van Gogh artworks
query = &amp;quot;[?isHighlight == `true`].[title, objectEndDate]&amp;quot;

# Applying the query to the collected response data
result = jmespath.search(query, response_vg_art)

# Display the identified important artworks
result&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="bash"&gt;&lt;code&gt;[[&amp;#39;Self-Portrait with a Straw Hat (obverse: The Potato Peeler)&amp;#39;, 1887],
 [&amp;#39;Wheat Field with Cypresses&amp;#39;, 1889],
 [&amp;#39;Corridor in the Asylum&amp;#39;, 1889],
 [&amp;#39;Irises&amp;#39;, 1890],
 [&amp;#39;Road in Etten&amp;#39;, 1881],
 [&amp;#39;Madame Roulin and Her Baby&amp;#39;, 1888]]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Explanation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;&lt;code&gt;[?isHighlight ==&lt;/code&gt;true&lt;code&gt;]&lt;/code&gt;&lt;/strong&gt;: This filter retrieves only the artworks where &lt;code&gt;isHighlight&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, meaning they are considered significant.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;&lt;code&gt;.[title, objectEndDate]&lt;/code&gt;&lt;/strong&gt;: This part projects the results to show only the &lt;strong&gt;title&lt;/strong&gt; and &lt;strong&gt;year&lt;/strong&gt; of each highlighted artwork.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="case-4-filtering-by-date-and-classification"&gt;üé® Case 4: Filtering by Date and Classification&lt;/h4&gt;
&lt;p&gt;In this case, we will analyze the works of Vincent van Gogh to understand how his themes and styles evolved before 1886. We seek to create a list of works that meet the following conditions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üìÖ Creation Date:&lt;/strong&gt; Works created before 1886.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üè∑Ô∏è Classification:&lt;/strong&gt; Exclude works classified as ‚ÄúPaintings.‚Äù&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;During his early years, Van Gogh‚Äôs artistic focus encompassed diverse forms of expression, including works in media such as drawing, printmaking, and watercolor. Also, the following bar chart represents the various tags associated with Van Gogh‚Äôs works from this period and allows us to explore the themes prevalent in his art, highlighting how they changed over time.&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;query = &amp;quot;[?(objectEndDate&amp;lt;=`1886`) &amp;amp;&amp;amp; (classification!=&amp;#39;painting&amp;#39;)].{title: title, year: objectEndDate, tags: tags[*].term}&amp;quot;
result = jmespath.search(query, response_vg_art)
data = pd.json_normalize(result)
data = data.explode(&amp;#39;tags&amp;#39;)

plt.figure(figsize=(12,5))
sns.catplot(data = data.groupby([&amp;#39;year&amp;#39;,&amp;#39;tags&amp;#39;],as_index=False)[&amp;#39;title&amp;#39;].count(), 
            y = &amp;#39;tags&amp;#39;,
            x = &amp;#39;title&amp;#39;,
            color = &amp;#39;#6387FD&amp;#39;, 
            edgecolor=&amp;#39;black&amp;#39;,
            kind=&amp;#39;bar&amp;#39;, col=&amp;#39;year&amp;#39;)
plt.show()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/output-plot-1.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="case-5-filtered-by-date-and-technique"&gt;üé® Case 5: Filtered by Date and Technique&lt;/h4&gt;
&lt;p&gt;In this case, we will analyze the techniques used by Van Gogh, including the combination of different materials and styles, which are key aspects of his artistic evolution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conditions:&lt;/strong&gt; * &lt;strong&gt;üìÖ Creation Date:&lt;/strong&gt; Works created before 1886 or those made with ink (the medium contains ‚Äúink‚Äù). * &lt;strong&gt;üè∑Ô∏è Tags:&lt;/strong&gt; In addition, the selected works must have tags related to women to observe the influence of such representations on his art.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The objective is to explore how the techniques used by Van Gogh and the themes related to women influenced his style and artistic development.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="python"&gt;&lt;code&gt;query = &amp;quot;&amp;quot;&amp;quot;[?(
               ( objectBeginDate &amp;lt;= `1886` || 
                contains(not_null(medium, &amp;#39;&amp;#39;), &amp;#39;ink&amp;#39;))   &amp;amp;&amp;amp;
                contains(not_null(tags[*].term, &amp;#39;&amp;#39;), &amp;#39;Women&amp;#39;)
            )]
                .{title: title, year: objectEndDate, medium: medium, tags: tags[*].term}&amp;quot;&amp;quot;&amp;quot;

result = jmespath.search(query, response_vg_art)

data = pd.json_normalize(result)
data&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/output-table-1.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="case-6-using-custom-functions-in-jmespath"&gt;üé® Case 6: Using Custom Functions in JMESPath&lt;/h4&gt;
&lt;p&gt;In this case, we have a large dataset from the museum‚Äôs ‚ÄúDrawings and Prints‚Äù department, containing over 100,000 works of art, many of which belong to Vincent Van Gogh. To manipulate this data more effectively, we implemented two custom functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;**üõ†Ô∏è Conversion to Lowercase (_func_to_lower)**: This function allows us to convert any string of text to lowercase, which is useful for standardizing comparisons between values.&lt;/li&gt;
&lt;li&gt;**üõ†Ô∏è Search with Regular Expressions (_func_contains_regex)**: With this function, we can search for patterns within text strings using regular expressions. This is particularly helpful when we want to identify artworks that contain specific terms or patterns in their descriptions, titles, or tags.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JMESPath&lt;/strong&gt; is a powerful query language for JSON, but it has certain limitations in its native functions. Therefore, the following code will provide a good way to implement these functionalities when needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="python"&gt;&lt;code&gt;import re
import jmespath
from jmespath import functions

class CustomFunctions(functions.Functions):
    # Function to convert text to lowercase
    @functions.signature({&amp;#39;types&amp;#39;: [&amp;#39;string&amp;#39;]})
    def _func_to_lower(self, s):
        if isinstance(s, str):
            return s.lower()
        raise TypeError(&amp;quot;Expected a string argument&amp;quot;)

    # Function to search with regular expressions
    @functions.signature({&amp;#39;types&amp;#39;: [&amp;#39;array&amp;#39;]})
    def _func_contains_regex(self, args):
        if len(args) != 2:
            raise TypeError(&amp;quot;Expected a list with exactly 2 items: [string, pattern]&amp;quot;)
        s, str_pattern = args
        if isinstance(s, str) and isinstance(str_pattern, str):
            pattern = re.compile(str_pattern, re.IGNORECASE)
            return bool(pattern.search(s))
        raise TypeError(&amp;quot;Expected two string arguments in the list&amp;quot;)

# Registering custom functions
options = jmespath.Options(custom_functions=CustomFunctions())&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;After registering the custom functions, we will query the dataset. I previously downloaded üìÑ&lt;strong&gt;JSON files&lt;/strong&gt; for each object I queried from the API and created individual üìÑ&lt;strong&gt;JSON files&lt;/strong&gt;. Subsequently, I will select 1,000 random files, all of which come from the ‚ÄúDrawings and Prints‚Äù department.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="python"&gt;&lt;code&gt;num_files = 1000
# Get the list of files in the directory
random.seed(123)
random_files = random.sample(os.listdir(&amp;#39;data/objects&amp;#39;), num_files)

# Read the data from the files
data_random_files = []
for file in tqdm(random_files):
    with open(f&amp;#39;data/objects/{file}&amp;#39;) as f:
        data_tmp = json.load(f)
    data_random_files.append(data_tmp)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="bash"&gt;&lt;code&gt;100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 1000/1000 [00:00&amp;lt;00:00, 1922.73it/s]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the data loaded, we can now use a &lt;strong&gt;JMESPath&lt;/strong&gt; query to find artworks related to women by applying the custom to_lower function within the query:&lt;/p&gt;
&lt;pre class="python"&gt;&lt;code&gt;query = &amp;quot;&amp;quot;&amp;quot;[?( contains(to_lower(title), &amp;#39;women&amp;#39;))] .{title: title, year: objectEndDate, medium: medium,artist_name: artistDisplayName, tags: tags[*].term}&amp;quot;&amp;quot;&amp;quot;
result = jmespath.search(query, data_random_files, options=options)
pd.json_normalize(result)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output shows a list of works with titles that include the term ‚Äúwomen,‚Äù providing insights into Van Gogh‚Äôs representation of women in his art.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/output-table-2.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id="case-7-importing-and-querying-a-large-number-of-json-files"&gt;üé® Case 7: Importing and Querying a Large Number of JSON Files&lt;/h4&gt;
&lt;p&gt;In the previous case, we defined a sample of 1,000 randomly selected entries. Now, we will conduct a performance test by running a query across all 176,000 JSON entries in the ‚ÄúDrawings and Prints‚Äù department.&lt;/p&gt;
&lt;p&gt;For this scenario, we‚Äôll reapply Use Cases 5 and 6, which were initially tailored for Vincent Van Gogh‚Äôs artworks. However, this time we‚Äôll execute the same queries on the entire dataset, expanding our analysis to encompass all available artworks.&lt;/p&gt;
&lt;p&gt;You can find the complete code and dataset for this tutorial in my GitHub repository. I‚Äôd appreciate it if you could star ‚≠êÔ∏è the repo if you find it helpful, and consider following me for updates on new tutorials and articles. Your support helps me grow within the tech community and allows me to continue creating more content.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/img/github-repo.png" style="display:¬†block; ¬† margin-left:¬†auto; ¬† margin-right:¬†auto;" style="width:50.0%" alt="" /&gt;
&lt;p class="caption"&gt;&lt;a href="https://github.com/r0mymendez/json-query/tree/master" class="uri"&gt;https://github.com/r0mymendez/json-query/tree/master&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h2 id="aws-cli-json-querying"&gt;üéõÔ∏è AWS CLI JSON Querying&lt;/h2&gt;
&lt;p&gt;JMESPath is a query language for JSON, integrated into &lt;strong&gt;AWS CLI&lt;/strong&gt;, that lets you filter and transform JSON data directly in the command line. However, while &lt;strong&gt;JMESPath&lt;/strong&gt; is excellent for simple queries directly within &lt;strong&gt;AWS CLI&lt;/strong&gt;, tools like jq offer extended capabilities for more complex data manipulation.&lt;/p&gt;
&lt;p&gt;For instance, &lt;code&gt;jp&lt;/code&gt; is a üîçcommand-line tool based on &lt;strong&gt;JMESPath&lt;/strong&gt;, which offers a similar query syntax, providing an alternative for filtering &lt;strong&gt;JSON&lt;/strong&gt; data quickly. In this tutorial, however, we use &lt;code&gt;jq&lt;/code&gt; for its advanced formatting and processing capabilities, which are ideal when working with downloaded &lt;strong&gt;JSON&lt;/strong&gt; files.&lt;/p&gt;
&lt;p&gt;In the examples below, we demonstrate how jq can be used alongside &lt;strong&gt;AWS CLI&lt;/strong&gt; to handle &lt;strong&gt;JSON&lt;/strong&gt; data , enabling us to extract specific elements from API responses and transform them as needed.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="use-cases-1"&gt;Use Cases&lt;/h3&gt;
&lt;h4 id="case-1-total-artworks-in-the-european-painters-department-validate-the-number-of-artworks-corresponding-to-department-9-which-is-the-department-for-painters-and-european-artists."&gt;üé® Case 1: Total Artworks in the European Painters Department Validate the number of artworks corresponding to department 9, which is the department for painters and European artists.&lt;/h4&gt;
&lt;pre class="bash"&gt;&lt;code&gt;aws s3 cp s3://data-met-api/raw-objects-by-deparments/objects_by_departmentId_9.json - | jq &amp;#39;{total_arts: .total}&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class="bash"&gt;&lt;code&gt;{
  &amp;quot;total_arts&amp;quot;: 176075
}&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id="case-2-extract-specific-keys-from-van-goghs-artwork-in-this-case-we-will-revisit-a-previous-exercise-where-we-wanted-to-extract-specific-keys-from-a-file.-we-will-take-the-json-files-corresponding-to-the-artwork-of-vincent-van-gogh."&gt;üé® Case 2: Extract Specific Keys from Van Gogh‚Äôs Artwork In this case, we will revisit a previous exercise where we wanted to extract specific keys from a file. We will take the üìÑ&lt;strong&gt;JSON files&lt;/strong&gt; corresponding to the artwork of Vincent van Gogh.&lt;/h4&gt;
&lt;pre class="bash"&gt;&lt;code&gt;aws s3 cp s3://data-met-api/raw-objects/object_id_436532.json - | jq -c &amp;#39;{ title_name: .title, date: .objectBeginDate, artist_name: .constituents[0].name, tags_name: [.tags[].term] }&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&amp;quot;title_name&amp;quot;:&amp;quot;Self-Portrait with a Straw Hat (obverse: The Potato Peeler)&amp;quot;,&amp;quot;date&amp;quot;:1887,&amp;quot;artist_name&amp;quot;:&amp;quot;Vincent van Gogh&amp;quot;,&amp;quot;tags_name&amp;quot;:[&amp;quot;Men&amp;quot;,&amp;quot;Self-portraits&amp;quot;]}&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id="caso-3-extracting-and-filtering-data-from-multiple-files-to-implement-one-of-the-more-complex-cases-of-iterating-through-multiple-files-and-filtering-data-we-will-create-a-shell-script.-below-we-will-generate-a-script-similar-to-one-of-the-previously-solved-cases-but-we-will-use-a-selection-query-to-apply-filters."&gt;üé® Caso 3: Extracting and Filtering Data from Multiple Files To implement one of the more complex cases of iterating through multiple files and filtering data, we will create a shell script. Below, we will generate a script similar to one of the previously solved cases, but we will use a selection query to apply filters.&lt;/h4&gt;
&lt;pre class="bash"&gt;&lt;code&gt;#!/bin/bash
bucket_name=&amp;quot;data-met-api&amp;quot;
path=&amp;quot;raw-objects&amp;quot;

# List of object IDs
ids_objects=(335538 436527 436530 436532 436529 436525 436534 336318 436526 437998 436533 436531 436535 335537 336327 437980 436528 459193 437984 335536 459123 436524 436536 438722)
total_objects=${#ids_objects[@]}

# Query
query=&amp;#39; select(.objectEndDate &amp;gt;= 1888) | {title_name: .title, date: .objectBeginDate, artist_name: .constituents[0].name, tags_name: [.tags[].term] }&amp;#39;
json_output=&amp;quot;&amp;quot; 

# Imprimir los IDs de objetos
for (( i=0; i&amp;lt;total_objects; i++ )); do
    id=${ids_objects[$i]}
    # Download the JSON file from S3 and extract the required fields
    response=$(aws s3 cp s3://$bucket_name/$path/object_id_$id.json - 2&amp;gt;/dev/null | jq &amp;quot;$query&amp;quot;)  # Capturar la salida correctamente
    
    # Validate the json_output variable is empty and add the response 
    if [ ! -z &amp;quot;$response&amp;quot; ]; then
        if [ -z &amp;quot;$json_output&amp;quot; ]; then
            json_output=&amp;quot;$response&amp;quot;
        else
            json_output+=&amp;quot;, $response&amp;quot;
        fi
    else
        echo &amp;quot;Warning: No valid data found for ID $id&amp;quot;
    fi

    progress=$(( (i + 1) * 100 / total_objects ))
    printf &amp;quot;\rProgress: [%-50s] %d%%&amp;quot; &amp;quot;$(printf &amp;#39;#%.0s&amp;#39; $(seq 1 $((progress / 2))))&amp;quot; &amp;quot;$progress&amp;quot;
    
done

# Create JSON array
json_output=&amp;quot;[$json_output]&amp;quot;

# Create the output.json file
echo &amp;quot;$json_output&amp;quot; &amp;gt; output.json&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h1 id="references"&gt;üìö References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[1] - The Metropolitan Museum of Art Collection API, URL:&lt;a href="https://metmuseum.github.io/" class="uri"&gt;https://metmuseum.github.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] - The MET, URL: &lt;a href="https://www.metmuseum.org/" class="uri"&gt;https://www.metmuseum.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] - JmesPath Documentation, URL: &lt;a href="https://jmespath.org/" class="uri"&gt;https://jmespath.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] - JmesPath Python library, URL: &lt;a href="https://github.com/jmespath/jmespath.py" class="uri"&gt;https://github.com/jmespath/jmespath.py&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[5] - AWS Command Line Interface: Filtering output in the AWS CLI, URL: &lt;a href="https://docs.aws.amazon.com/cli/v1/userguide/cli-usage-filter.html" class="uri"&gt;https://docs.aws.amazon.com/cli/v1/userguide/cli-usage-filter.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[6] - Github jp, URL: &lt;a href="https://github.com/jmespath/jp" class="uri"&gt;https://github.com/jmespath/jp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>9114b093cde2978de2b8ef51c92c4927</distill:md5>
      <category>Data</category>
      <category>Python</category>
      <category>Cloud Computing</category>
      <category>AWS</category>
      <guid>https://r0mymendez.github.io/posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks</guid>
      <pubDate>Thu, 02 Jan 2025 00:00:00 +0000</pubDate>
      <media:content url="https://r0mymendez.github.io/posts_en/2025-01-02-efficiently-querying-json-data-in-python-exploring-the-met-museums-artworks/preview.png" medium="image" type="image/png" width="1333" height="580"/>
    </item>
    <item>
      <title>My Preparation Journey for GitHub Fundamentals Certification</title>
      <dc:creator>Romina Mendez</dc:creator>
      <link>https://r0mymendez.github.io/posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification</link>
      <description>


&lt;p&gt;This month, I achieved the &lt;strong&gt;‚ÄúGitHub Fundamentals‚Äù&lt;/strong&gt; certification, and in this article, I want to share how I did it, what new things I learned, and what I didn‚Äôt know before but wish I had known earlier so I could have implemented it sooner.&lt;/p&gt;
&lt;h1 id="what-is-the-github-platform"&gt;What is the GitHub Platform?&lt;/h1&gt;
&lt;p&gt;The &lt;strong&gt;GitHub&lt;/strong&gt; platform is a cloud-based solution built on &lt;strong&gt;Git&lt;/strong&gt;, a version control system. It facilitates collaboration and project management through a range of features and AI-powered tools, enabling efficient software development, while ensuring quality and secure deployment.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Some features we can highlight are as follows:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ü§ñ AI&lt;/strong&gt;: GitHub uses products like Copilot, which will be described later, to help develop and solve problems and perform automated security reviews. This enhances collaboration, productivity, and security.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ü§ù Collaboration&lt;/strong&gt;: GitHub facilitates efficient collaboration with tools such as Repositories, Issues, and Pull Requests. These features allow multidisciplinary teams to work together quickly, reduce approval times, and accelerate project delivery.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;‚öôÔ∏è Productivity&lt;/strong&gt;: Automation through GitHub Actions enables developers to focus on creating solutions and avoid repetitive manual tasks.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîí Security&lt;/strong&gt;: GitHub includes features like Dependabot and automated security reviews, ensuring that code remains private and protected within the organization.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üåç Scalability&lt;/strong&gt;: GitHub boasts the largest developer community in the world, with over 100 million developers and more than 330 million repositories.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîó Integration&lt;/strong&gt;: Additionally, GitHub offers an API that allows for integrations and customization of workflows, as well as automation of tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id="github-functionalities-products"&gt;üü† GitHub Functionalities &amp;amp; Products&lt;/h1&gt;
&lt;p&gt;As mentioned initially, this post is intended to discuss what you need to know in order to pass the certification exam. Below, we have an image that represents each of the described entities and the topics you should study to successfully pass the certification exam, which consists of &lt;strong&gt;‚úèÔ∏è 75 multiple-choice questions&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This mental map represents how I organized the key concepts needed to prepare for the certification, following the GitHub Foundation Learning Path, which I will explain next.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-2.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="github-foundations-learning-path"&gt;üü† GitHub Foundations Learning Path&lt;/h1&gt;
&lt;p&gt;In order to effectively study and understand all the essential content for the certification, I completed the &lt;a href="https://learn.microsoft.com/en-us/collections/o1njfe825p602p"&gt;&lt;strong&gt;‚ÄòGitHub Foundations Learning Path‚Äô&lt;/strong&gt;&lt;/a&gt; provided by &lt;strong&gt;Microsoft Learn&lt;/strong&gt;. This path consists of 15 modules, totaling approximately ‚åõ 10 hours, with each module averaging about ‚åõ 35 minutes. The journey combines üìö theoretical knowledge with ‚úèÔ∏èhands-on exercises, enabling me to effectively learn and apply the concepts.&lt;/p&gt;
&lt;h2 id="practices-with-github-actions"&gt;Practices with GitHub Actions&lt;/h2&gt;
&lt;p&gt;The modules include ‚úèÔ∏è hands-on exercises solved in stages, using &lt;strong&gt;GitHub Actions&lt;/strong&gt; to validate each step of the process. This inspired me to develop similar tutorials for future posts.&lt;/p&gt;
&lt;h2 id="interactive-console"&gt;Interactive Console&lt;/h2&gt;
&lt;p&gt;Some modules, such as the first one, offer an interactive console that facilitates executing typical Git commands, further enhancing the learning experience.&lt;/p&gt;
&lt;h2 id="knowledge-check"&gt;Knowledge Check&lt;/h2&gt;
&lt;p&gt;Each unit includes a set of ‚úèÔ∏èquestions to validate what has been learned, similar to those found on the exam. &amp;gt; üôå I recommend completing and reviewing these questions to consolidate the knowledge acquired.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id="overview-of-units"&gt;üü† Overview of Units&lt;/h1&gt;
&lt;p&gt;With the foundational concepts established, I will now delve into a detailed description of each unit. Below, you will find explanations of the key elements and tools I studied, and how I organized them to effectively prepare for the certification.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="code-management"&gt;üü† Code Management&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Code management on GitHub&lt;/strong&gt; is essential for productivity and effective collaboration within development teams. Below are the key tools that facilitate this management:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-11.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="repository"&gt;üìÅ Repository&lt;/h3&gt;
&lt;p&gt;The &lt;strong&gt;repository&lt;/strong&gt; is the core component of a project on GitHub, which is where the source code, along with its version history, documentation, and other relevant resources for the project, is stored.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="pull-requests"&gt;üîÑ Pull Requests&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Pull Requests (PRs)&lt;/strong&gt; are a fundamental tool for collaboration on GitHub. They allow developers to propose changes to the source code, which can then be reviewed and discussed by other team members before being merged into the base code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pull Request States&lt;/strong&gt; It is important to understand the possible states of a Pull Request (PR) on GitHub, which can be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Draft&lt;/strong&gt;: PRs in draft status are still in development and not yet ready for formal review. This state allows collaborators to work on a proposal before requesting official feedback.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Open&lt;/strong&gt;: Open PRs are ready and available for review and discussion by project collaborators. This is where proposed changes are evaluated before deciding whether to integrate them into the base code.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Closed&lt;/strong&gt;: Closed PRs have not been accepted and therefore will not be merged into the project‚Äôs base code. This state may indicate that the proposal was rejected or that the author decided not to proceed with it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Merged&lt;/strong&gt;: Merged PRs have been accepted, and the proposed changes have been successfully integrated with the main branch of the project. This is the final state of a successful PR.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id="issues"&gt;üîß Issues&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Issues&lt;/strong&gt; are tracking tickets used to report bugs, suggest improvements, or discuss new features. They are essential for planning and organizing work within a project, allowing teams to prioritize tasks and track progress.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="discussions"&gt;üí¨ Discussions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Discussions on GitHub&lt;/strong&gt; provide a space where collaborators can engage in broader conversations about the project. These discussions can be organized into several categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üì¢ Announcements:&lt;/strong&gt; For communicating important updates about the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üí¨ General:&lt;/strong&gt; For general conversations that don‚Äôt fit into any other category.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üí° Ideas:&lt;/strong&gt; For proposing and debating new ideas or improvements.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üó≥Ô∏è Polls:&lt;/strong&gt; For conducting surveys and gathering community opinions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üôè Q&amp;amp;A:&lt;/strong&gt; For questions and answers about the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üôå Show and Tell:&lt;/strong&gt; For sharing achievements, demos, or use cases of the project.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="gists"&gt;üìÅ Gists&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Gists&lt;/strong&gt; are a simple way to share snippets of code or text. They can be public, accessible to anyone, or private, visible only to the creator or those with whom the link is shared. Gists are useful for quickly sharing code examples, notes, or scripts among collaborators or with the broader community.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="accounts"&gt;üü† Accounts&lt;/h3&gt;
&lt;p&gt;This is one of the topics where you may encounter questions, and within the recommended learning path, you can find three types of accounts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üë•Personal Account&lt;/strong&gt;: This is the basic account for individual users, allowing them to own and manage repositories, packages, and projects.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üè¢ Organization Account&lt;/strong&gt;: Allows multiple users to collaborate on shared projects.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üíº Enterprise Account&lt;/strong&gt;: Designed for large companies, it enables centralized management of policies and billing for multiple organizations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-3.png" /&gt;&lt;/p&gt;
&lt;p&gt;Additionally, the existing plans are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GitHub Free:&lt;/strong&gt; Provides the essentials for individuals and organizations, with limited storage and GitHub Actions minutes.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GitHub Pro:&lt;/strong&gt; Extends the features of GitHub Free with more GitHub Actions minutes, storage, and advanced tools for private repositories, ideal for individual developers.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GitHub Team:&lt;/strong&gt; Similar to GitHub Pro but optimized for organizations, adding advanced team collaboration capabilities.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;GitHub Enterprise:&lt;/strong&gt; Offers premium support, enhanced security, compliance, and advanced authentication options, along with significantly increased resources and storage. There are two versions of this account type:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cloud&lt;/strong&gt; (hosted by GitHub)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt; (self-managed)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="methodologies"&gt;üü† Methodologies&lt;/h2&gt;
&lt;p&gt;I‚Äôve titled this section ‚ÄúMethodologies‚Äù because throughout different chapters of the learning path, I encountered several methodologies that you need to learn. Therefore, I decided to group them all under the same concept.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;‚ö†Ô∏è Remember that this is my approach to studying for the certification, and you might find that the learning path or other resources refer to these methodologies differently.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-4.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;üîÄ GitHub Flow:&lt;/strong&gt; A workflow that utilizes specific components (branches, commits, and pull requests) to collaborate and experiment with new features or fixes in a software project.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;üîÑ InnerSource:&lt;/strong&gt; Involves adopting open-source practices and principles, such as transparency and collaboration, within an organization. This means projects are shared internally, allowing any team member to access, modify, and contribute to the code, similar to an open-source project but within the organization.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;üõ†Ô∏è Contributing to Projects:&lt;/strong&gt; I consider this a methodology because GitHub enables active participation in open-source projects through its platform. This practice is not only fundamental for collaborative software development but also promotes learning, innovation, and community building among developers. Key considerations include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üì¢ Identification and Communication:&lt;/strong&gt; Before making changes, it‚Äôs important to communicate your intentions with the project‚Äôs maintainers, whether you are addressing an existing issue or proposing a new feature.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîÑ Creating a Pull Request:&lt;/strong&gt; Once changes are made, a pull request is created on GitHub, allowing others to review, discuss, and eventually merge it with the main codebase.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîéReview and Adjustments:&lt;/strong&gt; The pull request is reviewed by the project maintainers, who may request adjustments. It‚Äôs essential to be open to feedback and willing to make necessary changes for your contribution to be accepted.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üë• Iteration and Ongoing Collaboration:&lt;/strong&gt; The review and discussion process around a pull request is iterative and collaborative, allowing for improved software quality and ensuring each contribution aligns with the project‚Äôs standards and goals.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;‚ù§Ô∏è Supporting Projects Financially&lt;/strong&gt;: In addition to contributing code and feedback, you can also support open-source projects financially. For this reason, GitHub Sponsors allows you to fund projects and individuals to help them continue their open-source work, while giving them the recognition they deserve. To support a project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Identify Projects&lt;/strong&gt;: Explore and select projects you are passionate about.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Choose a Sponsorship Level&lt;/strong&gt;: Pick a tier that fits your budget and desired level of support, with varying benefits such as exclusive content or early access to new features.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Support and Recognition&lt;/strong&gt;: Find the Sponsor button on a project‚Äôs main page if it‚Äôs eligible for sponsorship. You can select the sponsorship tier and decide if you want your contribution to be public.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/github-sponsor.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;source: &lt;a href="https://learn.microsoft.com/en-us/training/modules/contribute-open-source/2-identify"&gt;Identify where you can help&lt;/a&gt;&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/github-tier.png" alt="" /&gt;
&lt;p class="caption"&gt;source: &lt;a href="https://learn.microsoft.com/en-us/training/modules/contribute-open-source/2-identify"&gt;Identify where you can help&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2 id="communication"&gt;üü† Communication&lt;/h2&gt;
&lt;p&gt;Communication within a repository is essential and encompasses the detailed documentation of objectives, changes, methodologies, and rules to be applied. Below are the main tools and practices that facilitate this communication:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;üìÑ README File:&lt;/strong&gt; The README file is the first line of communication in a project. It should contain essential information about the project‚Äôs purpose, how to use it, how to set it up, and any other relevant details that users and collaborators need to know.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;üìö Wiki:&lt;/strong&gt; This section is designed to host more extensive and detailed documentation. Unlike the README, which is brief and direct, the Wiki is ideal for sharing content such as use cases, examples, design principles, technical details, and any other aspects that require a more in-depth explanation.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-5.png" /&gt;&lt;/p&gt;
&lt;h3 id="markdown"&gt;üìù Markdown&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Markdown is a markup language&lt;/strong&gt; that provides a simple and efficient way to format and style content in issues, README files, wikis, and any other textual documentation within a repository.&lt;/p&gt;
&lt;p&gt;If you‚Äôre not familiar with Markdown, I recommend checking out the &lt;a href="https://www.datacamp.com/cheat-sheet/markdown-cheat-sheet-23"&gt;DataCamp CheatSheet&lt;/a&gt;, which summarizes everything you need to get started. Additionally, within the chapter, there‚Äôs an exercise titled &lt;a href="https://learn.microsoft.com/en-us/training/modules/communicate-using-markdown/3-communicating-using-markdown"&gt;‚ÄúExercise - Communicate using Markdown‚Äù&lt;/a&gt; that will allow you to apply and reinforce your practice using markdown.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/makdown-datacamp.png" width="576" alt="" /&gt;
&lt;p class="caption"&gt;source: &lt;a href="https://www.datacamp.com/cheat-sheet/markdown-cheat-sheet-23"&gt;DataCamp CheatSheet&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr /&gt;
&lt;h2 id="products"&gt;üü† Products&lt;/h2&gt;
&lt;p&gt;I have titled this section &lt;strong&gt;‚ÄúProducts‚Äù&lt;/strong&gt; as it includes two chapters dedicated to two key products. One of these products leverages AI, while the other focuses on enhancing productivity.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-6.png" /&gt;&lt;/p&gt;
&lt;h3 id="github-copilot"&gt;üöÄ GitHub Copilot&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GitHub Copilot&lt;/strong&gt; is an AI-powered assistance tool for developers. Its main features include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üí¨ GitHub Copilot Chat&lt;/strong&gt;: Provides a chat within the editor for code analysis, generating unit tests, and fixing bugs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîÑ Copilot for Pull Requests&lt;/strong&gt;: Automatically adds labels to pull request descriptions using AI to facilitate review.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üìÑ AI-Generated Documentation Answers&lt;/strong&gt;: Delivers AI-generated responses to questions about documentation and technologies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;‚öôÔ∏è Copilot for CLI&lt;/strong&gt;: Assists in creating complex commands and loops in the command line.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="github-codespaces"&gt;üöÄ GitHub Codespaces&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GitHub Codespaces&lt;/strong&gt; provides configurable development environments in the cloud, built on Docker container. Therefore every each Codespace operates within a üêã Docker container hosted on GitHub. Also, this container includes all the necessary tools and settings for your project, ensuring a consistent and reproducible environment for all project contributors.&lt;/p&gt;
&lt;p&gt;Here‚Äôs an overview of the key functionalities and states of a Codespace:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üõ†Ô∏è Creating Codespaces:&lt;/strong&gt; You can create a Codespace from templates, repository branches, open pull requests, or historical commits. By default, each Codespace is based on an Ubuntu Linux image, but you can customize it with any Linux distribution to meet your specific needs. This provides a complete development environment running inside a Docker container on a virtual machine. You can create multiple Codespaces per repository or branch, though there is a limit on the number of simultaneous Codespaces.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üì• Saving Changes:&lt;/strong&gt; Changes made within a Codespace are automatically saved when connected through the web. To avoid losing work if the Codespace is deleted, it is crucial to commit and push changes to a remote repository.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîÑ Reopening and Using Codespaces:&lt;/strong&gt; You can reopen active or stopped Codespaces from GitHub.com, Visual Studio Code, JetBrains IDE, or GitHub CLI. When connected, you access the Docker container of the Codespace, ensuring a consistent development environment accessible from anywhere.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;‚è±Ô∏è Timeout and Internet Connection:&lt;/strong&gt; Codespaces automatically stop after 30 minutes of inactivity. They require an internet connection, and any uncommitted changes are saved to prevent data loss.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üîß Closing, Stopping, or Rebuilding a Codespace:&lt;/strong&gt; You can stop or restart a Codespace to apply configuration changes or troubleshoot issues. You can also rebuild the Codespace to update the Docker container configuration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;üóëÔ∏è Deleting a Codespace:&lt;/strong&gt; You can delete a Codespace after committing your changes. Inactive Codespaces are automatically deleted after 30 days, though this period can be adjusted. Using Docker containers ensures that your development environment is consistent and reproducible, making it easier to collaborate and maintain projects.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="project"&gt;üü† Project&lt;/h2&gt;
&lt;p&gt;GitHub has introduced new types of projects that significantly enhance productivity and project management. While previously existing projects focused primarily on code management, the new GitHub Projects integrate key elements that allow you to manage not only the code but also the broader aspects of project management within a single tool.&lt;/p&gt;
&lt;p&gt;This new approach aims to streamline workflows, provide more comprehensive tracking, and improve collaboration. It‚Äôs important to note that there may be questions about the differences between the previous project types and these new ones. In the following sections, I‚Äôll highlight the functionalities and benefits of the new project types, helping you understand how they differ from the old ones and how they can be utilized to optimize project management.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-7.png" /&gt;&lt;/p&gt;
&lt;h3 id="view"&gt;üìã View&lt;/h3&gt;
&lt;p&gt;In GitHub Projects, tasks are represented as issues and can include key details such as title, description, assignee, start date, and complexity. These issues can be customized with various field types like text, number, date, single selection (for dropdown lists), or iteration to better suit your needs.&lt;/p&gt;
&lt;p&gt;The types of views that can be generated are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üìÑ Table&lt;/strong&gt;: A &lt;code&gt;tabular view&lt;/code&gt; that organizes issues in a table format. This view is primarily used to view and manage detailed information on multiple issues simultaneously, facilitating comparison and bulk editing of data.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/github-project-table.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;üìã Board&lt;/strong&gt;: A &lt;code&gt;card-based view&lt;/code&gt; where issues are organized into columns, typically by status or category. This view is primarily used to visualize the workflow of issues through different stages, aiding task management and progress tracking.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/github-project-board.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;‚åõ Roadmap&lt;/strong&gt;: A graphical view that shows a timeline of issues and the associated milestones. This view is primarily used for planning and visualizing the long-term evolution of projects, helping to identify dependencies and delivery schedules.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/github-project-roadmap.png" /&gt;&lt;/p&gt;
&lt;h3 id="insights"&gt;üìä Insights&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Insights in Projects&lt;/strong&gt; allows you to &lt;code&gt;visualize&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;, and &lt;code&gt;customize&lt;/code&gt; &lt;code&gt;charts&lt;/code&gt; using the elements added to your Project as data sources. When creating a chart, you can define filters, the type of chart, and the information to be displayed. The generated charts are available to anyone with access to the Project.&lt;/p&gt;
&lt;p&gt;These charts enable you to analyze and manage the project, enhancing your ability to plan, control, and assess the project‚Äôs progress.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/github-insights.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="task-automation"&gt;ü§ñ Task Automation&lt;/h3&gt;
&lt;p&gt;Task automation on GitHub is important for improving efficiency and consistency in project management. The following are the key tools that facilitate this automation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Workflows:&lt;/strong&gt; Workflows are the simplest way to automate project management on GitHub. These workflows allow you to automate repetitive processes such as &lt;code&gt;updating task statuses&lt;/code&gt;, &lt;code&gt;running tests&lt;/code&gt;, &lt;code&gt;deployments&lt;/code&gt;, and &lt;code&gt;other actions&lt;/code&gt; defined in YAML files. Integrated workflows in GitHub Projects streamline automation without the need for complex configurations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GraphQL API:&lt;/strong&gt; The GraphQL API offers more granular control over project automation. With GraphQL, you can customize how you interact with your project data, enabling advanced automations tailored to your team‚Äôs specific needs.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub Actions:&lt;/strong&gt; GitHub Actions provides a powerful platform for further customizing automation in your projects. With GitHub Actions, you can create pipelines that respond to specific events, such as the creation of issues or changes in task statuses, ensuring that all activities in your project are executed consistently and automatically.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="security"&gt;üü† Security&lt;/h2&gt;
&lt;p&gt;Security is a fundamental aspect within GitHub, which provides a range of tools and best practices to enhance security in software development.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-8.png" /&gt;&lt;/p&gt;
&lt;h3 id="authentication-access-controls"&gt;üîê Authentication &amp;amp; Access Controls&lt;/h3&gt;
&lt;p&gt;Access to your GitHub account can be enhanced with advanced authentication methods that validate user identity more securely. * &lt;strong&gt;SAML SSO Authentication&lt;/strong&gt;: Allows user authentication through a centralized Identity Provider (IdP), enhancing security and access control. * &lt;strong&gt;Multifactor Authentication (2FA)&lt;/strong&gt;: Adds an extra layer of security through two-step authentication, which may include physical security keys and time-based one-time password (TOTP) applications.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id="vulnerability-alerts"&gt;‚ö†Ô∏è Vulnerability Alerts&lt;/h3&gt;
&lt;p&gt;GitHub offers vulnerability alerts to help you identify and address security issues in your repositories.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dependabot Alerts&lt;/strong&gt;: Detects and notifies you about vulnerable dependencies in your project, helping you keep your libraries and packages up to date.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/github-dependabot-alerts.png" alt="Image description" /&gt; &amp;gt; source:&lt;a href="https://learn.microsoft.com/en-us/training/modules/maintain-secure-repository-github/3-security-automation"&gt;Automated security&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Code Scanning&lt;/strong&gt;: Analyzes your code for vulnerabilities and errors. It can be customized using CodeQL, allowing you to detect and fix security issues before they become risks. Integration with other tools like SonarQube or Policy Validator for Terraform by Amazon Web Services is also possible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Secret Scanning&lt;/strong&gt;: Automatically scans the repository for exposed credentials or secrets, helping to prevent misuse of sensitive information.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="reporting"&gt;üìä Reporting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Security Policy&lt;/strong&gt;: The security policy for your project should be documented in a &lt;code&gt;SECURITY.md&lt;/code&gt; file, detailing how to responsibly report vulnerabilities.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="best-practices"&gt;üöÄ Best Practices&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keep Sensitive Information Secure&lt;/strong&gt;: It‚Äôs crucial to protect sensitive information by ensuring it is not included in commits. Use &lt;code&gt;.gitignore&lt;/code&gt; to exclude critical files and carefully review changes before committing them.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Branch Protection Rules&lt;/strong&gt;: Set up protection rules for key branches like &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;develop&lt;/code&gt;, requiring approved reviews before allowing merges. This ensures that only secure and reviewed code is integrated into the main branches.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id="types-of-search-on-github"&gt;üü† Types of Search on GitHub&lt;/h2&gt;
&lt;p&gt;On GitHub, you can use advanced search to efficiently navigate repositories, find issues, review pull requests, and join discussions. Here are some practical examples to enhance your search capabilities and collaboration on projects:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-9.png" /&gt;&lt;/p&gt;
&lt;h3 id="search-examples"&gt;Search Examples&lt;/h3&gt;
&lt;h4 id="repositories"&gt;üîé Repositories&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description&lt;/strong&gt;: Finds repositories related to ‚Äúmachine learning‚Äù with more than 1000 stars.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;: Ideal for locating popular projects in a specific area of interest.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- --&gt;
&lt;pre&gt;&lt;code&gt;topic:machine-learning stars:&amp;gt;1000&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="issues-in-a-specific-repository"&gt;üîé Issues in a Specific Repository&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description&lt;/strong&gt;: Searches for closed issues within the &lt;code&gt;r0mymendez/datapp&lt;/code&gt; repository.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;: Useful for reviewing the history of resolved issues in a particular repository.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- --&gt;
&lt;pre&gt;&lt;code&gt;repo:r0mymendez/datapp is:issue is:closed&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="issues-with-labels-and-status"&gt;üîé Issues with Labels and Status&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description&lt;/strong&gt;: Finds open issues tagged with ‚Äúhelp-wanted‚Äù in projects using Python.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;: Perfect for finding opportunities to contribute to Python projects where maintainers are seeking help.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- --&gt;
&lt;pre&gt;&lt;code&gt;is:issue language:python is:open label:help-wanted&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="pull-requests-1"&gt;üîé Pull Requests&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description&lt;/strong&gt;: Shows all pull requests where a review has been requested from you.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;: Ideal for managing your code review responsibilities.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- --&gt;
&lt;pre&gt;&lt;code&gt;is:pr review-requested:@m&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="discussions-1"&gt;üîé Discussions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description&lt;/strong&gt;: Finds open discussions in repositories related to the Python language.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;: Useful for participating in relevant conversations or searching for open topics in a specific programming language.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- --&gt;
&lt;pre&gt;&lt;code&gt;in:discussions is:open language:python&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="issues-with-specific-combinations"&gt;Issues with Specific Combinations&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Description&lt;/strong&gt;: Searches for open issues in repositories related to ‚Äúmachine learning‚Äù with more than 1000 stars, tagged with ‚Äúhelp-wanted,‚Äù and using Python.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;: Ideal for finding open issues in popular machine learning projects that are seeking help in Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- --&gt;
&lt;pre&gt;&lt;code&gt;topic:machine-learning stars:&amp;gt;1000 is:issue label:help-wanted language:python is:open&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id="summary"&gt;üü† Summary&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://r0mymendez.github.io//posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/img/img-10.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id="references"&gt;üìö References&lt;/h2&gt;
&lt;p&gt;The following references were used to create this article, with the first being the primary resource and the other materials were utilized to practice and simulate the exam.&lt;/p&gt;
&lt;ol style="list-style-type: decimal"&gt;
&lt;li&gt;&lt;strong&gt;GitHub Foundations Learning Path&lt;/strong&gt;: &lt;a href="https://learn.microsoft.com/en-us/collections/o1njfe825p602p"&gt;GitHub Foundations Learning Path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub Foundations Practice Test&lt;/strong&gt;: Contains a series of multiple-choice questions for exam simulation. &lt;a href="https://ghcertified.com/practice_tests/foundations/"&gt;GitHub Foundations Practice Test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Study Guide GitHub Foundations&lt;/strong&gt;: A PDF guide for studying and preparing for the exam. &lt;a href="https://assets.ctfassets.net/wfutmusr1t3h/1kmMx7AwI4qH8yIZgOmQlP/79e6ff1dfdee589d84a24dd763b1eef7/github-foundations-exam-study-guide__1_.pdf"&gt;Study Guide GitHub Foundations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitHub Foundations Certification ‚Äì Exam Prep Guide&lt;/strong&gt;: This is a post in FreeCodeCamp blog and it is content very helpful, and this post provides a good summary of everything you should know for exam preparation. &lt;a href="https://www.freecodecamp.org/news/github-foundations-certified-exam-prep-guide/"&gt;GitHub Foundations Certification ‚Äì Exam Prep Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="section"&gt;&lt;/h2&gt;
&lt;pre class="r distill-force-highlighting-css"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      <distill:md5>676c6f23c55726e59407c6fcfbb81e9c</distill:md5>
      <category>DevOps</category>
      <category>GIT</category>
      <category>Methodologies</category>
      <guid>https://r0mymendez.github.io/posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification</guid>
      <pubDate>Tue, 20 Aug 2024 00:00:00 +0000</pubDate>
      <media:content url="https://r0mymendez.github.io/posts_en/2024-08-20-my-preparation-journey-for-github-fundamentals-certification/preview.png" medium="image" type="image/png" width="3386" height="1301"/>
    </item>
    <item>
      <title>Employing AWS Comprehend Medical for Medical Data Extraction in Healthcare Analytics</title>
      <dc:creator>Romina Mendez</dc:creator>
      <link>https://r0mymendez.github.io/posts_en/2024-08-07-employing-aws-comprehend-medical-for-medical-data-extraction-in-healthcare-analytics</link>
      <description>The goal of this tutorial is to provide a guide on how to use Amazon Comprehend Medical for identifying medical entities and extracting information, including RxNorm codes, SNOMED CT concepts, and other attributes.</description>
      <category>Python</category>
      <category>Data</category>
      <category>Cloud Computing</category>
      <category>AI</category>
      <guid>https://r0mymendez.github.io/posts_en/2024-08-07-employing-aws-comprehend-medical-for-medical-data-extraction-in-healthcare-analytics</guid>
      <pubDate>Wed, 07 Aug 2024 00:00:00 +0000</pubDate>
      <media:content url="https://r0mymendez.github.io/posts_en/2024-08-07-employing-aws-comprehend-medical-for-medical-data-extraction-in-healthcare-analytics/preview.jpg" medium="image" type="image/jpeg"/>
    </item>
  </channel>
</rss>
